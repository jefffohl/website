/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/page"],{

/***/ "(app-pages-browser)/./animations/script.ts":
/*!******************************!*\
  !*** ./animations/script.ts ***!
  \******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildAndAnimateGrid: () => (/* binding */ buildAndAnimateGrid)\n/* harmony export */ });\n/**\n *  Art is a constant process of inventing ways to escape the restrictions of past inventions.\n */ // types\nvar GridType = /*#__PURE__*/ function(GridType) {\n    GridType[\"ROW\"] = \"row\";\n    GridType[\"COLUMN\"] = \"column\";\n    return GridType;\n}(GridType || {});\nvar CellDrawDirection = /*#__PURE__*/ function(CellDrawDirection) {\n    CellDrawDirection[\"UP\"] = \"up\";\n    CellDrawDirection[\"DOWN\"] = \"down\";\n    CellDrawDirection[\"LEFT\"] = \"left\";\n    CellDrawDirection[\"RIGHT\"] = \"right\";\n    return CellDrawDirection;\n}(CellDrawDirection || {});\n// constants\nconst SWEETNESS = 24;\nconst INTERVAL = 100;\nconst HUE_RANGE = 40;\nconst SATURATION_RANGE = 50;\nconst LIGHTNESS_RANGE = 50;\nclass GridAnimator {\n    /**\n     * Initializes the animation on the specified canvas\n     */ start() {\n        if (!this.canvas || !this.context) {\n            console.error('Canvas not available');\n            return;\n        }\n        this.animationRunning = true;\n        this.createGrid();\n    }\n    /**\n     * Stops animation and cleans up resources\n     */ stop() {\n        // Set flag first to stop any new animations from starting\n        this.animationRunning = false;\n        // Clear any timeouts\n        if (this.timeoutId !== null) {\n            window.clearTimeout(this.timeoutId);\n            this.timeoutId = null;\n        }\n        // Clean up data that might be holding references\n        this.flatGrid = [];\n        this.grid = null;\n    }\n    /**\n     * Clean up resources when component unmounts\n     */ destroy() {\n        // Stop the animation first\n        this.stop();\n        // Release references to DOM elements\n        if (this.canvas) {\n            // Clear the canvas to prevent memory leaks\n            if (this.context) {\n                this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n            }\n        }\n        this.canvas = null;\n        this.context = null;\n    }\n    /**\n     * Generates a random window of given range within given domain\n     * @param domain the maximum (assuming all domains start with 0)\n     * @param range the length of the window\n     */ generateClamp(domain, range) {\n        // generate random starting point, based on domain minus the range. e.g. with a domain of 0 to 360,\n        // and the range is 50, then we choose a starting number between 0 and 310.\n        // this is the beginning of the clamp.\n        const start = Math.floor(Math.random() * (domain - range));\n        return [\n            start,\n            start + range\n        ];\n    }\n    generateCircularClamp(domain, range) {\n        // because hue is a circular range - going from 0 to 360, we could have a clamp\n        // which starts at 300, and ends at 40. So, any number above 300 or below 40 would\n        // be a valid value in this range.\n        const start = Math.floor(Math.random() * domain);\n        let end = start + range;\n        if (end > domain) {\n            end = start + range - domain;\n        }\n        return [\n            start,\n            end\n        ];\n    }\n    getRandomHue() {\n        const min = this.hueClamp[0];\n        const max = this.hueClamp[1] < this.hueClamp[0] ? 360 + this.hueClamp[1] : this.hueClamp[1];\n        const value = Math.floor(Math.random() * (max - min) + min);\n        return value > 360 ? value - 360 : value;\n    }\n    getRandomClamped(min, max) {\n        min = Math.ceil(min);\n        max = Math.floor(max);\n        return Math.floor(Math.random() * (max - min) + min);\n    }\n    randomColor() {\n        return \"hsl(\".concat(this.getRandomHue(), \" \").concat(this.getRandomClamped(this.saturationClamp[0], this.saturationClamp[1]), \"% \").concat(this.getRandomClamped(this.lightnessClamp[0], this.lightnessClamp[1]), \"%)\");\n    }\n    generatePalette() {\n        this.hueClamp = this.generateCircularClamp(360, HUE_RANGE);\n        this.saturationClamp = this.generateClamp(100, SATURATION_RANGE);\n        this.lightnessClamp = this.generateClamp(100, LIGHTNESS_RANGE);\n        this.backgroundColor = this.randomColor();\n    }\n    sum(partialSum, a) {\n        return partialSum + a;\n    }\n    /**\n     * Function for generating a random number, with an upper bound\n     * determined by a diminishing probability.\n     * @param sweetness This parameter determines how likely the random number is to be large.\n     * Lower numbers reduce the probability, larger numbers increase the probability.\n     */ getValue(sweet) {\n        let count = 0;\n        let coefficient = 1 / sweet;\n        let progress = false;\n        while(!progress){\n            if (Math.random() <= coefficient) {\n                progress = true;\n            }\n            count++;\n            coefficient = coefficient + 1 / sweet;\n        }\n        return count;\n    }\n    createSpread(count) {\n        const spread = [];\n        let remaining = 1;\n        // Create 4 random numbers between 0 and 1 and sort them\n        const randomPoints = [];\n        for(let i = 0; i < count - 1; i++){\n            randomPoints.push(Math.random());\n        }\n        randomPoints.sort((a, b)=>a - b);\n        // Use these random points to create 5 random chunks\n        let previousPoint = 0;\n        for (const point of randomPoints){\n            const chunkSize = point - previousPoint;\n            spread.push(chunkSize);\n            remaining -= chunkSize;\n            previousPoint = point;\n        }\n        spread.push(remaining) // Last chunk is whatever is remaining\n        ;\n        return spread;\n    }\n    setupCanvas(canvasId) {\n        var _this_canvas;\n        this.canvas = document.getElementById(canvasId);\n        if ((_this_canvas = this.canvas) === null || _this_canvas === void 0 ? void 0 : _this_canvas.getContext) {\n            var _this_context;\n            const dpr = window.devicePixelRatio;\n            const rect = this.canvas.getBoundingClientRect();\n            this.canvas.width = rect.width * dpr;\n            this.canvas.height = rect.height * dpr;\n            this.context = this.canvas.getContext('2d');\n            (_this_context = this.context) === null || _this_context === void 0 ? void 0 : _this_context.scale(dpr, dpr);\n            this.gridHeight = rect.height;\n            this.gridWidth = rect.width;\n        }\n    }\n    createGridScaffold() {\n        const columnLength = this.getValue(SWEETNESS);\n        const rowLength = this.getValue(SWEETNESS);\n        const gridScaffold = {\n            columns: this.createSpread(columnLength),\n            rows: this.createSpread(rowLength)\n        };\n        return gridScaffold;\n    }\n    chooseGridType() {\n        return Math.random() >= 0.5 ? \"row\" : \"column\";\n    }\n    generateRow(parentCell, columns) {\n        return columns.map((column, index)=>{\n            const width = parentCell.width * column;\n            const top = parentCell.top;\n            const left = columns.slice(0, index).reduce(this.sum, 0) * parentCell.width + parentCell.left;\n            return {\n                left,\n                top,\n                width,\n                depth: parentCell.depth + 1,\n                height: parentCell.height,\n                color: this.randomColor(),\n                children: [],\n                drawDirection: \"right\",\n                originalDimensions: {\n                    height: 0,\n                    width: 0\n                }\n            };\n        });\n    }\n    generateColumn(parentCell, rows) {\n        return rows.map((row, index)=>{\n            const height = parentCell.height * row;\n            const left = parentCell.left;\n            const top = rows.slice(0, index).reduce(this.sum, 0) * parentCell.height + parentCell.top;\n            return {\n                left,\n                top,\n                height,\n                depth: parentCell.depth + 1,\n                width: parentCell.width,\n                color: this.randomColor(),\n                children: [],\n                drawDirection: \"down\",\n                originalDimensions: {\n                    height: 0,\n                    width: 0\n                }\n            };\n        });\n    }\n    getLevel2Columns() {\n        if (!this.gridScaffold) return [];\n        // we add a little extra spiciness to the columns for fun:\n        const breakoutChance = 0.01 * SWEETNESS;\n        const skipCells = [];\n        const newColumns = [];\n        this.gridScaffold.columns.forEach((column, columnIndex)=>{\n            if (skipCells.includes(columnIndex)) {\n                return;\n            }\n            if (columnIndex + 1 === this.gridScaffold.columns.length) {\n                newColumns.push(column);\n                return;\n            }\n            // for each cell, determine if it will break out\n            // if it does break out, determine how many cells to break out\n            if (Math.random() < breakoutChance) {\n                const numberOfRemainingColumns = this.gridScaffold.columns.length - (columnIndex + 1);\n                // randomly select the number of columns we want to span to the right\n                const columnSpan = Math.ceil(Math.random() * numberOfRemainingColumns);\n                const newColumn = this.gridScaffold.columns.slice(columnIndex, columnIndex + columnSpan).reduce(this.sum, 0);\n                for(let c = 0; c < columnSpan - 1; c++){\n                    skipCells.push(c + columnIndex + 1);\n                }\n                newColumns.push(newColumn);\n            } else {\n                newColumns.push(column);\n            }\n        });\n        return newColumns;\n    }\n    generateChildren(parentCell) {\n        if (!this.gridScaffold) return [];\n        // Depth level 0 is the top level grid cell - there can be only one!\n        // Depth level 1 are the cells of that make up the top rows\n        // Depth level 2 are the cells that make up the columns\n        // Below level 2 children do not adhere to the grid scaffold\n        if (parentCell.depth === 0) {\n            return this.generateColumn(parentCell, this.gridScaffold.rows);\n        } else if (parentCell.depth === 1) {\n            return this.generateRow(parentCell, this.getLevel2Columns());\n        } else {\n            const gridType = this.chooseGridType();\n            const spread = this.createSpread(this.getValue(SWEETNESS));\n            return gridType === \"column\" ? this.generateColumn(parentCell, spread) : this.generateRow(parentCell, spread);\n        }\n    }\n    generateGrid(cell) {\n        this.flatGrid.push(cell);\n        if (cell.depth < 2) {\n            cell.children = this.generateChildren(cell);\n            cell.children.forEach((child)=>{\n                this.generateGrid(child);\n            });\n        } else if (cell.depth < 4) {\n            if (Math.random() < 0.0075 * SWEETNESS) {\n                cell.children = this.generateChildren(cell);\n                cell.children.forEach((child)=>{\n                    this.generateGrid(child);\n                });\n            }\n        }\n    }\n    drawCell(index) {\n        return new Promise((resolve, reject)=>{\n            if (!this.context || !this.animationRunning) {\n                return reject(false);\n            }\n            if (this.flatGrid[index].children.length > 0) {\n                return resolve(true);\n            }\n            const cell = this.flatGrid[index];\n            this.context.fillStyle = cell.color;\n            let startTimestamp;\n            let limitValue;\n            let animationFrameId;\n            switch(cell.drawDirection){\n                case \"down\":\n                case \"up\":\n                    limitValue = cell.height - cell.originalDimensions.height;\n                    break;\n                case \"right\":\n                case \"left\":\n                    limitValue = cell.width - cell.originalDimensions.width;\n                    break;\n                default:\n                    limitValue = 0;\n            }\n            const incrementCell = (increment)=>{\n                // if the drawDirection is:\n                // RIGHT: we incrementally increase the width\n                // LEFT: we incrementally increase the width value and decrement the left.\n                // UP: we incrementally increase the height and decrement the top value.\n                // DOWN: we incrementally increase the height\n                switch(cell.drawDirection){\n                    case \"down\":\n                        return {\n                            top: cell.top,\n                            left: cell.left,\n                            height: increment,\n                            width: cell.width\n                        };\n                    case \"up\":\n                        return {\n                            top: cell.top + cell.height - cell.originalDimensions.height - increment,\n                            left: cell.left,\n                            height: cell.originalDimensions.height + increment,\n                            width: cell.width\n                        };\n                    case \"left\":\n                        return {\n                            top: cell.top,\n                            left: cell.left + cell.width - cell.originalDimensions.width - increment,\n                            height: cell.height,\n                            width: cell.originalDimensions.width + increment\n                        };\n                    case \"right\":\n                        return {\n                            top: cell.top,\n                            left: cell.left,\n                            height: cell.height,\n                            width: increment\n                        };\n                    default:\n                        return {\n                            top: 0,\n                            left: 0,\n                            height: 0,\n                            width: 0\n                        };\n                }\n            };\n            const draw = (timeStamp)=>{\n                if (!this.context || !this.animationRunning) {\n                    cancelAnimationFrame(animationFrameId);\n                    reject(false);\n                    return;\n                }\n                if (!startTimestamp) {\n                    startTimestamp = timeStamp;\n                }\n                const elapsed = timeStamp - startTimestamp;\n                const relativeProgress = elapsed / INTERVAL;\n                const increment = limitValue * Math.min(relativeProgress, 1);\n                const newDimensions = incrementCell(increment);\n                this.context.fillRect(newDimensions.left, newDimensions.top, newDimensions.width, newDimensions.height);\n                if (elapsed >= INTERVAL) {\n                    resolve(true);\n                } else {\n                    animationFrameId = window.requestAnimationFrame(draw);\n                }\n            };\n            animationFrameId = window.requestAnimationFrame(draw);\n            // Cleanup function for the promise\n            return ()=>{\n                if (animationFrameId) {\n                    cancelAnimationFrame(animationFrameId);\n                }\n            };\n        });\n    }\n    drawLoaderCell(pause) {\n        if (!this.context || !this.animationRunning) return;\n        this.context.fillStyle = this.backgroundColor;\n        let startTimestamp;\n        const draw = (timeStamp)=>{\n            if (!this.context || !this.animationRunning) return;\n            if (!startTimestamp) {\n                startTimestamp = timeStamp;\n            }\n            const elapsed = timeStamp - startTimestamp;\n            const relativeProgress = elapsed / pause;\n            const increment = this.gridWidth * Math.min(relativeProgress, 1);\n            this.context.fillRect(0, 0, increment, 5);\n            if (elapsed >= pause) {\n                return;\n            } else {\n                window.requestAnimationFrame(draw);\n            }\n        };\n        window.requestAnimationFrame(draw);\n    }\n    degenerateChildren(cells) {\n        var _cells_;\n        // first, both combatants must have no children:\n        if (cells[0].children.length > 0) {\n            cells[0].children = this.degenerateChildren(cells[0].children);\n            return cells;\n        }\n        if (((_cells_ = cells[1]) === null || _cells_ === void 0 ? void 0 : _cells_.children.length) > 0) {\n            cells[1].children = this.degenerateChildren(cells[1].children);\n            return cells;\n        }\n        if (cells.length === 1 && cells[0].children.length === 0) {\n            return [];\n        }\n        const gridType = cells[0].top === cells[1].top ? \"row\" : \"column\";\n        const winner = Math.random();\n        const newCells = cells.filter((_cell, index)=>{\n            if (winner < 0.5 && index === 1) {\n                return false;\n            }\n            if (winner >= 0.5 && index === 0) {\n                return false;\n            }\n            return true;\n        }).map((cell)=>{\n            // if the cell index is the first, it is the winner\n            // was it the first or the second?\n            // if winner < 0.5 it was the first\n            // if winner >= 0.5 it was the second\n            const drawDirection = winner < 0.5 ? cell.drawDirection : gridType === \"column\" ? \"up\" : \"left\";\n            return {\n                ...cell,\n                color: cell.depth < 2 ? this.backgroundColor : cell.color,\n                drawDirection,\n                originalDimensions: {\n                    height: cell.height,\n                    width: cell.width\n                }\n            };\n        });\n        if (gridType === \"column\") {\n            newCells[0].height = cells[0].height + cells[1].height;\n            if (winner >= 0.5) {\n                newCells[0].top = cells[0].top;\n            }\n        }\n        if (gridType === \"row\") {\n            newCells[0].width = cells[0].width + cells[1].width;\n            if (winner >= 0.5) {\n                newCells[0].left = cells[0].left;\n            }\n        }\n        // push the winner\n        this.flatGrid.push(newCells[0]);\n        return newCells;\n    }\n    destroyGrid() {\n        var _gridCell_children;\n        if (!this.animationRunning) return;\n        const gridCell = this.flatGrid[0];\n        this.flatGrid = [];\n        while((gridCell === null || gridCell === void 0 ? void 0 : (_gridCell_children = gridCell.children) === null || _gridCell_children === void 0 ? void 0 : _gridCell_children.length) > 0){\n            gridCell.children = this.degenerateChildren(gridCell.children);\n        }\n        this.animateGrid();\n    }\n    createGrid() {\n        if (!this.context || !this.animationRunning) return;\n        this.context.fillStyle = this.backgroundColor;\n        this.context.fillRect(0, 0, this.gridWidth, this.gridHeight);\n        this.gridScaffold = this.createGridScaffold();\n        this.grid = {\n            height: this.gridHeight,\n            width: this.gridWidth,\n            top: 0,\n            left: 0,\n            children: [],\n            depth: 0,\n            color: this.backgroundColor,\n            drawDirection: \"right\",\n            originalDimensions: {\n                height: this.gridHeight,\n                width: this.gridWidth\n            }\n        };\n        this.flatGrid = [];\n        this.generateGrid(this.grid);\n        this.animateGrid();\n    }\n    checkGrid() {\n        const totalGridSize = this.gridWidth * this.gridHeight;\n        const totalCellSize = this.flatGrid.filter((cell)=>cell.children.length === 0).map((c)=>c.height * c.width).reduce(this.sum, 0);\n        console.warn(totalGridSize, totalCellSize);\n    }\n    async animateGrid() {\n        if (!this.animationRunning) return;\n        if (this.flatGrid[this.index]) {\n            try {\n                await this.drawCell(this.index);\n                this.index++;\n                if (this.index < this.flatGrid.length) {\n                    if (this.animationRunning) {\n                        // Use requestAnimationFrame to avoid stack overflow with deep recursion\n                        window.requestAnimationFrame(()=>this.animateGrid());\n                    }\n                } else {\n                    var _this_flatGrid_, _this_flatGrid_1;\n                    this.index = 0;\n                    // if the last cell in the flat grid is the same dimensions as the gridWidth and gridHeight, then we just finished\n                    // destroying the grid, and need to start a new grid\n                    if (Math.round((_this_flatGrid_ = this.flatGrid[this.flatGrid.length - 1]) === null || _this_flatGrid_ === void 0 ? void 0 : _this_flatGrid_.width) === this.gridWidth && Math.round((_this_flatGrid_1 = this.flatGrid[this.flatGrid.length - 1]) === null || _this_flatGrid_1 === void 0 ? void 0 : _this_flatGrid_1.height) === this.gridHeight) {\n                        this.createGrid();\n                    } else {\n                        this.generatePalette();\n                        this.timeoutId = window.setTimeout(()=>{\n                            if (this.animationRunning) {\n                                this.destroyGrid();\n                            }\n                        }, 3000);\n                    }\n                }\n            } catch (error) {\n                // If an error occurs (like when component is destroyed), just stop the animation\n                // without logging an error, as this is expected behavior when stopping\n                if (this.animationRunning) {\n                    console.error('Error animating grid:', error);\n                }\n            }\n        } else {\n            this.index++;\n            if (this.index < this.flatGrid.length && this.animationRunning) {\n                window.requestAnimationFrame(()=>this.animateGrid());\n            }\n        }\n    }\n    constructor(canvasId){\n        this.context = null;\n        this.grid = null;\n        this.flatGrid = [];\n        this.gridScaffold = null;\n        this.index = 0;\n        this.gridHeight = 0;\n        this.gridWidth = 0;\n        this.hueClamp = [\n            0,\n            0\n        ];\n        this.saturationClamp = [\n            0,\n            0\n        ];\n        this.lightnessClamp = [\n            0,\n            0\n        ];\n        this.backgroundColor = '';\n        this.canvas = null;\n        this.animationRunning = false;\n        this.timeoutId = null;\n        this.setupCanvas(canvasId);\n        this.generatePalette();\n    }\n}\nconst buildAndAnimateGrid = (canvasId)=>{\n    const animator = new GridAnimator(canvasId);\n    animator.start();\n    return animator;\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FuaW1hdGlvbnMvc2NyaXB0LnRzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7Q0FFQyxHQUVELFFBQVE7QUFNUixzQ0FBS0E7OztXQUFBQTtFQUFBQTtBQW1CTCwrQ0FBS0M7Ozs7O1dBQUFBO0VBQUFBO0FBT0wsWUFBWTtBQUNaLE1BQU1DLFlBQVk7QUFDbEIsTUFBTUMsV0FBVztBQUNqQixNQUFNQyxZQUFZO0FBQ2xCLE1BQU1DLG1CQUFtQjtBQUN6QixNQUFNQyxrQkFBa0I7QUFFeEIsTUFBTUM7SUFxQkY7O0tBRUMsR0FDRCxRQUFxQjtRQUNqQixJQUFJLENBQUMsSUFBSSxDQUFDRSxNQUFNLElBQUksQ0FBQyxJQUFJLENBQUNDLE9BQU8sRUFBRTtZQUMvQkMsUUFBUUMsS0FBSyxDQUFDO1lBQ2Q7UUFDSjtRQUVBLElBQUksQ0FBQ0MsZ0JBQWdCLEdBQUc7UUFDeEIsSUFBSSxDQUFDQyxVQUFVO0lBQ25CO0lBRUE7O0tBRUMsR0FDRCxPQUFvQjtRQUNoQiwwREFBMEQ7UUFDMUQsSUFBSSxDQUFDRCxnQkFBZ0IsR0FBRztRQUV4QixxQkFBcUI7UUFDckIsSUFBSSxJQUFJLENBQUNHLFNBQVMsS0FBSyxNQUFNO1lBQ3pCQyxPQUFPQyxZQUFZLENBQUMsSUFBSSxDQUFDRixTQUFTO1lBQ2xDLElBQUksQ0FBQ0EsU0FBUyxHQUFHO1FBQ3JCO1FBRUEsaURBQWlEO1FBQ2pELElBQUksQ0FBQ0csUUFBUSxHQUFHLEVBQUU7UUFDbEIsSUFBSSxDQUFDQyxJQUFJLEdBQUc7SUFDaEI7SUFFQTs7S0FFQyxHQUNELFVBQXVCO1FBQ25CLDJCQUEyQjtRQUMzQixJQUFJLENBQUNMLElBQUk7UUFFVCxxQ0FBcUM7UUFDckMsSUFBSSxJQUFJLENBQUNOLE1BQU0sRUFBRTtZQUNiLDJDQUEyQztZQUMzQyxJQUFJLElBQUksQ0FBQ0MsT0FBTyxFQUFFO2dCQUNkLElBQUksQ0FBQ0EsT0FBTyxDQUFDWSxTQUFTLENBQ2xCLEdBQ0EsR0FDQSxJQUFJLENBQUNiLE1BQU0sQ0FBQ2MsS0FBSyxFQUNqQixJQUFJLENBQUNkLE1BQU0sQ0FBQ2UsTUFBTTtZQUUxQjtRQUNKO1FBRUEsSUFBSSxDQUFDZixNQUFNLEdBQUc7UUFDZCxJQUFJLENBQUNDLE9BQU8sR0FBRztJQUNuQjtJQUVBOzs7O0tBSUMsR0FDRCxjQUFzQmdCLE1BQWMsRUFBRUMsS0FBYSxFQUFvQjtRQUNuRSxtR0FBbUc7UUFDbkcsMkVBQTJFO1FBQzNFLHNDQUFzQztRQUN0QyxNQUFNbkIsUUFBUW9CLEtBQUtDLEtBQUssQ0FBQ0QsS0FBS0UsTUFBTSxLQUFNSixDQUFBQSxTQUFTQyxLQUFJO1FBQ3ZELE9BQU87WUFBQ25CO1lBQU9BLFFBQVFtQjtTQUFNO0lBQ2pDO0lBRVFJLHNCQUNKTCxNQUFjLEVBQ2RDLEtBQWEsRUFDRztRQUNoQiwrRUFBK0U7UUFDL0Usa0ZBQWtGO1FBQ2xGLGtDQUFrQztRQUNsQyxNQUFNbkIsUUFBUW9CLEtBQUtDLEtBQUssQ0FBQ0QsS0FBS0UsTUFBTSxLQUFLSjtRQUN6QyxJQUFJTSxNQUFNeEIsUUFBUW1CO1FBQ2xCLElBQUlLLE1BQU1OLFFBQVE7WUFDZE0sTUFBTXhCLFFBQVFtQixRQUFRRDtRQUMxQjtRQUNBLE9BQU87WUFBQ2xCO1lBQU93QjtTQUFJO0lBQ3ZCO0lBRVFDLGVBQXVCO1FBQzNCLE1BQU1DLE1BQU0sSUFBSSxDQUFDQyxRQUFRLENBQUMsRUFBRTtRQUM1QixNQUFNQyxNQUNGLElBQUksQ0FBQ0QsUUFBUSxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUNBLFFBQVEsQ0FBQyxFQUFFLEdBQzdCLE1BQU0sSUFBSSxDQUFDQSxRQUFRLENBQUMsRUFBRSxHQUN0QixJQUFJLENBQUNBLFFBQVEsQ0FBQyxFQUFFO1FBQzFCLE1BQU1FLFFBQVFULEtBQUtDLEtBQUssQ0FBQ0QsS0FBS0UsTUFBTSxLQUFNTSxDQUFBQSxNQUFNRixHQUFFLElBQUtBO1FBQ3ZELE9BQU9HLFFBQVEsTUFBTUEsUUFBUSxNQUFNQTtJQUN2QztJQUVRQyxpQkFBaUJKLEdBQVcsRUFBRUUsR0FBVyxFQUFVO1FBQ3ZERixNQUFNTixLQUFLVyxJQUFJLENBQUNMO1FBQ2hCRSxNQUFNUixLQUFLQyxLQUFLLENBQUNPO1FBQ2pCLE9BQU9SLEtBQUtDLEtBQUssQ0FBQ0QsS0FBS0UsTUFBTSxLQUFNTSxDQUFBQSxNQUFNRixHQUFFLElBQUtBO0lBQ3BEO0lBRVFNLGNBQXNCO1FBQzFCLE9BQU8sT0FBOEIsT0FBdkIsSUFBSSxDQUFDUCxZQUFZLElBQUcsS0FHNUIsT0FIK0IsSUFBSSxDQUFDSyxnQkFBZ0IsQ0FDdEQsSUFBSSxDQUFDRyxlQUFlLENBQUMsRUFBRSxFQUN2QixJQUFJLENBQUNBLGVBQWUsQ0FBQyxFQUFFLEdBQ3pCLE1BR0EsT0FISSxJQUFJLENBQUNILGdCQUFnQixDQUN2QixJQUFJLENBQUNJLGNBQWMsQ0FBQyxFQUFFLEVBQ3RCLElBQUksQ0FBQ0EsY0FBYyxDQUFDLEVBQUUsR0FDeEI7SUFDTjtJQUVRQyxrQkFBd0I7UUFDNUIsSUFBSSxDQUFDUixRQUFRLEdBQUcsSUFBSSxDQUFDSixxQkFBcUIsQ0FBQyxLQUFLM0I7UUFDaEQsSUFBSSxDQUFDcUMsZUFBZSxHQUFHLElBQUksQ0FBQ2hCLGFBQWEsQ0FBQyxLQUFLcEI7UUFDL0MsSUFBSSxDQUFDcUMsY0FBYyxHQUFHLElBQUksQ0FBQ2pCLGFBQWEsQ0FBQyxLQUFLbkI7UUFDOUMsSUFBSSxDQUFDc0MsZUFBZSxHQUFHLElBQUksQ0FBQ0osV0FBVztJQUMzQztJQUVRSyxJQUFJQyxVQUFrQixFQUFFQyxDQUFTLEVBQVU7UUFDL0MsT0FBT0QsYUFBYUM7SUFDeEI7SUFFQTs7Ozs7S0FLQyxHQUNELFNBQWlCRSxLQUFhLEVBQVU7UUFDcEMsSUFBSUMsUUFBUTtRQUNaLElBQUlDLGNBQWMsSUFBSUY7UUFDdEIsSUFBSUcsV0FBVztRQUNmLE1BQU8sQ0FBQ0EsU0FBVTtZQUNkLElBQUl4QixLQUFLRSxNQUFNLE1BQU1xQixhQUFhO2dCQUM5QkMsV0FBVztZQUNmO1lBQ0FGO1lBQ0FDLGNBQWNBLGNBQWMsSUFBSUY7UUFDcEM7UUFDQSxPQUFPQztJQUNYO0lBRVFHLGFBQWFILEtBQWEsRUFBWTtRQUMxQyxNQUFNSSxTQUFTLEVBQUU7UUFDakIsSUFBSUMsWUFBWTtRQUNoQix3REFBd0Q7UUFDeEQsTUFBTUMsZUFBZSxFQUFFO1FBQ3ZCLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJUCxRQUFRLEdBQUdPLElBQUs7WUFDaENELGFBQWFFLElBQUksQ0FBQzlCLEtBQUtFLE1BQU07UUFDakM7UUFDQTBCLGFBQWFHLElBQUksQ0FBQyxDQUFDWixHQUFHYSxJQUFNYixJQUFJYTtRQUNoQyxvREFBb0Q7UUFDcEQsSUFBSUMsZ0JBQWdCO1FBQ3BCLEtBQUssTUFBTUMsU0FBU04sYUFBYztZQUM5QixNQUFNTyxZQUFZRCxRQUFRRDtZQUMxQlAsT0FBT0ksSUFBSSxDQUFDSztZQUNaUixhQUFhUTtZQUNiRixnQkFBZ0JDO1FBQ3BCO1FBQ0FSLE9BQU9JLElBQUksQ0FBQ0gsV0FBVyxzQ0FBc0M7O1FBQzdELE9BQU9EO0lBQ1g7SUFFUVUsWUFBWUMsUUFBZ0IsRUFBUTtZQUlwQztRQUhKLElBQUksQ0FBQ3hELE1BQU0sR0FBR3lELFNBQVNDLGNBQWMsQ0FDakNGO1FBRUosS0FBSSxtQkFBSSxDQUFDeEQsTUFBTSxjQUFYLGdEQUFhMkQsVUFBVSxFQUFFO2dCQU16QjtZQUxBLE1BQU1DLE1BQU1wRCxPQUFPcUQsZ0JBQWdCO1lBQ25DLE1BQU1DLE9BQU8sSUFBSSxDQUFDOUQsTUFBTSxDQUFDK0QscUJBQXFCO1lBQzlDLElBQUksQ0FBQy9ELE1BQU0sQ0FBQ2MsS0FBSyxHQUFHZ0QsS0FBS2hELEtBQUssR0FBRzhDO1lBQ2pDLElBQUksQ0FBQzVELE1BQU0sQ0FBQ2UsTUFBTSxHQUFHK0MsS0FBSy9DLE1BQU0sR0FBRzZDO1lBQ25DLElBQUksQ0FBQzNELE9BQU8sR0FBRyxJQUFJLENBQUNELE1BQU0sQ0FBQzJELFVBQVUsQ0FBQzthQUN0QyxvQkFBSSxDQUFDMUQsT0FBTyxjQUFaLGtEQUFjK0QsS0FBSyxDQUFDSixLQUFLQTtZQUN6QixJQUFJLENBQUNLLFVBQVUsR0FBR0gsS0FBSy9DLE1BQU07WUFDN0IsSUFBSSxDQUFDbUQsU0FBUyxHQUFHSixLQUFLaEQsS0FBSztRQUMvQjtJQUNKO0lBRVFxRCxxQkFBbUM7UUFDdkMsTUFBTUMsZUFBZSxJQUFJLENBQUM3QixRQUFRLENBQUM5QztRQUNuQyxNQUFNNEUsWUFBWSxJQUFJLENBQUM5QixRQUFRLENBQUM5QztRQUNoQyxNQUFNNkUsZUFBZTtZQUNqQkMsU0FBUyxJQUFJLENBQUMzQixZQUFZLENBQUN3QjtZQUMzQkksTUFBTSxJQUFJLENBQUM1QixZQUFZLENBQUN5QjtRQUM1QjtRQUNBLE9BQU9DO0lBQ1g7SUFFUUcsaUJBQTJCO1FBQy9CLE9BQU90RCxLQUFLRSxNQUFNLE1BQU07SUFDNUI7SUFFUXFELFlBQVlDLFVBQWdCLEVBQUVKLE9BQWlCLEVBQVU7UUFDN0QsT0FBT0EsUUFBUUssR0FBRyxDQUFDLENBQUNDLFFBQWdCQztZQUNoQyxNQUFNaEUsUUFBUTZELFdBQVc3RCxLQUFLLEdBQUcrRDtZQUNqQyxNQUFNRSxNQUFNSixXQUFXSSxHQUFHO1lBQzFCLE1BQU1DLE9BQ0ZULFFBQVFVLEtBQUssQ0FBQyxHQUFHSCxPQUFPSSxNQUFNLENBQUMsSUFBSSxDQUFDOUMsR0FBRyxFQUFFLEtBQUt1QyxXQUFXN0QsS0FBSyxHQUM5RDZELFdBQVdLLElBQUk7WUFDbkIsT0FBTztnQkFDSEE7Z0JBQ0FEO2dCQUNBakU7Z0JBQ0FxRSxPQUFPUixXQUFXUSxLQUFLLEdBQUc7Z0JBQzFCcEUsUUFBUTRELFdBQVc1RCxNQUFNO2dCQUN6QnFFLE9BQU8sSUFBSSxDQUFDckQsV0FBVztnQkFDdkJzRCxVQUFVLEVBQUU7Z0JBQ1pDLGFBQWE7Z0JBQ2JDLG9CQUFvQjtvQkFDaEJ4RSxRQUFRO29CQUNSRCxPQUFPO2dCQUNYO1lBQ0o7UUFDSjtJQUNKO0lBRVEwRSxlQUFlYixVQUFnQixFQUFFSCxJQUFjLEVBQVU7UUFDN0QsT0FBT0EsS0FBS0ksR0FBRyxDQUFDLENBQUNhLEtBQWFYO1lBQzFCLE1BQU0vRCxTQUFTNEQsV0FBVzVELE1BQU0sR0FBRzBFO1lBQ25DLE1BQU1ULE9BQU9MLFdBQVdLLElBQUk7WUFDNUIsTUFBTUQsTUFDRlAsS0FBS1MsS0FBSyxDQUFDLEdBQUdILE9BQU9JLE1BQU0sQ0FBQyxJQUFJLENBQUM5QyxHQUFHLEVBQUUsS0FBS3VDLFdBQVc1RCxNQUFNLEdBQzVENEQsV0FBV0ksR0FBRztZQUNsQixPQUFPO2dCQUNIQztnQkFDQUQ7Z0JBQ0FoRTtnQkFDQW9FLE9BQU9SLFdBQVdRLEtBQUssR0FBRztnQkFDMUJyRSxPQUFPNkQsV0FBVzdELEtBQUs7Z0JBQ3ZCc0UsT0FBTyxJQUFJLENBQUNyRCxXQUFXO2dCQUN2QnNELFVBQVUsRUFBRTtnQkFDWkMsYUFBYTtnQkFDYkMsb0JBQW9CO29CQUNoQnhFLFFBQVE7b0JBQ1JELE9BQU87Z0JBQ1g7WUFDSjtRQUNKO0lBQ0o7SUFFUTRFLG1CQUE2QjtRQUNqQyxJQUFJLENBQUMsSUFBSSxDQUFDcEIsWUFBWSxFQUFFLE9BQU8sRUFBRTtRQUVqQywwREFBMEQ7UUFDMUQsTUFBTXFCLGlCQUFpQixPQUFPbEc7UUFDOUIsTUFBTW1HLFlBQXNCLEVBQUU7UUFDOUIsTUFBTUMsYUFBdUIsRUFBRTtRQUMvQixJQUFJLENBQUN2QixZQUFZLENBQUNDLE9BQU8sQ0FBQ3VCLE9BQU8sQ0FBQyxDQUFDakIsUUFBUWtCO1lBQ3ZDLElBQUlILFVBQVVJLFFBQVEsQ0FBQ0QsY0FBYztnQkFDakM7WUFDSjtZQUNBLElBQUlBLGNBQWMsTUFBTSxJQUFJLENBQUN6QixZQUFZLENBQUVDLE9BQU8sQ0FBQzBCLE1BQU0sRUFBRTtnQkFDdkRKLFdBQVc1QyxJQUFJLENBQUM0QjtnQkFDaEI7WUFDSjtZQUNBLGdEQUFnRDtZQUNoRCw4REFBOEQ7WUFDOUQsSUFBSTFELEtBQUtFLE1BQU0sS0FBS3NFLGdCQUFnQjtnQkFDaEMsTUFBTU8sMkJBQ0YsSUFBSSxDQUFDNUIsWUFBWSxDQUFFQyxPQUFPLENBQUMwQixNQUFNLEdBQUlGLENBQUFBLGNBQWM7Z0JBQ3ZELHFFQUFxRTtnQkFDckUsTUFBTUksYUFBYWhGLEtBQUtXLElBQUksQ0FDeEJYLEtBQUtFLE1BQU0sS0FBSzZFO2dCQUVwQixNQUFNRSxZQUFZLElBQUksQ0FBQzlCLFlBQVksQ0FBRUMsT0FBTyxDQUFDVSxLQUFLLENBQzlDYyxhQUNBQSxjQUFjSSxZQUNoQmpCLE1BQU0sQ0FBQyxJQUFJLENBQUM5QyxHQUFHLEVBQUU7Z0JBQ25CLElBQUssSUFBSWlFLElBQUksR0FBR0EsSUFBSUYsYUFBYSxHQUFHRSxJQUFLO29CQUNyQ1QsVUFBVTNDLElBQUksQ0FBQ29ELElBQUlOLGNBQWM7Z0JBQ3JDO2dCQUNBRixXQUFXNUMsSUFBSSxDQUFDbUQ7WUFDcEIsT0FBTztnQkFDSFAsV0FBVzVDLElBQUksQ0FBQzRCO1lBQ3BCO1FBQ0o7UUFDQSxPQUFPZ0I7SUFDWDtJQUVRUyxpQkFBaUIzQixVQUFnQixFQUFVO1FBQy9DLElBQUksQ0FBQyxJQUFJLENBQUNMLFlBQVksRUFBRSxPQUFPLEVBQUU7UUFFakMsb0VBQW9FO1FBQ3BFLDJEQUEyRDtRQUMzRCx1REFBdUQ7UUFDdkQsNERBQTREO1FBQzVELElBQUlLLFdBQVdRLEtBQUssS0FBSyxHQUFHO1lBQ3hCLE9BQU8sSUFBSSxDQUFDSyxjQUFjLENBQUNiLFlBQVksSUFBSSxDQUFDTCxZQUFZLENBQUNFLElBQUk7UUFDakUsT0FBTyxJQUFJRyxXQUFXUSxLQUFLLEtBQUssR0FBRztZQUMvQixPQUFPLElBQUksQ0FBQ1QsV0FBVyxDQUFDQyxZQUFZLElBQUksQ0FBQ2UsZ0JBQWdCO1FBQzdELE9BQU87WUFDSCxNQUFNYSxXQUFXLElBQUksQ0FBQzlCLGNBQWM7WUFDcEMsTUFBTTVCLFNBQVMsSUFBSSxDQUFDRCxZQUFZLENBQUMsSUFBSSxDQUFDTCxRQUFRLENBQUM5QztZQUMvQyxPQUFPOEcsd0JBQ0QsSUFBSSxDQUFDZixjQUFjLENBQUNiLFlBQVk5QixVQUNoQyxJQUFJLENBQUM2QixXQUFXLENBQUNDLFlBQVk5QjtRQUN2QztJQUNKO0lBRVEyRCxhQUFhQyxJQUFVLEVBQVE7UUFDbkMsSUFBSSxDQUFDL0YsUUFBUSxDQUFDdUMsSUFBSSxDQUFDd0Q7UUFDbkIsSUFBSUEsS0FBS3RCLEtBQUssR0FBRyxHQUFHO1lBQ2hCc0IsS0FBS3BCLFFBQVEsR0FBRyxJQUFJLENBQUNpQixnQkFBZ0IsQ0FBQ0c7WUFDdENBLEtBQUtwQixRQUFRLENBQUNTLE9BQU8sQ0FBQyxDQUFDWTtnQkFDbkIsSUFBSSxDQUFDRixZQUFZLENBQUNFO1lBQ3RCO1FBQ0osT0FBTyxJQUFJRCxLQUFLdEIsS0FBSyxHQUFHLEdBQUc7WUFDdkIsSUFBSWhFLEtBQUtFLE1BQU0sS0FBSyxTQUFTNUIsV0FBVztnQkFDcENnSCxLQUFLcEIsUUFBUSxHQUFHLElBQUksQ0FBQ2lCLGdCQUFnQixDQUFDRztnQkFDdENBLEtBQUtwQixRQUFRLENBQUNTLE9BQU8sQ0FBQyxDQUFDWTtvQkFDbkIsSUFBSSxDQUFDRixZQUFZLENBQUNFO2dCQUN0QjtZQUNKO1FBQ0o7SUFDSjtJQUVRQyxTQUFTN0IsS0FBYSxFQUFvQjtRQUM5QyxPQUFPLElBQUk4QixRQUFRLENBQUNDLFNBQVNDO1lBQ3pCLElBQUksQ0FBQyxJQUFJLENBQUM3RyxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUNHLGdCQUFnQixFQUFFO2dCQUN6QyxPQUFPMEcsT0FBTztZQUNsQjtZQUNBLElBQUksSUFBSSxDQUFDcEcsUUFBUSxDQUFDb0UsTUFBTSxDQUFDTyxRQUFRLENBQUNZLE1BQU0sR0FBRyxHQUFHO2dCQUMxQyxPQUFPWSxRQUFRO1lBQ25CO1lBRUEsTUFBTUosT0FBTyxJQUFJLENBQUMvRixRQUFRLENBQUNvRSxNQUFNO1lBQ2pDLElBQUksQ0FBQzdFLE9BQU8sQ0FBQzhHLFNBQVMsR0FBR04sS0FBS3JCLEtBQUs7WUFDbkMsSUFBSTRCO1lBQ0osSUFBSUM7WUFDSixJQUFJQztZQUVKLE9BQVFULEtBQUtuQixhQUFhO2dCQUN0QjtnQkFDQTtvQkFDSTJCLGFBQWFSLEtBQUsxRixNQUFNLEdBQUcwRixLQUFLbEIsa0JBQWtCLENBQUN4RSxNQUFNO29CQUN6RDtnQkFDSjtnQkFDQTtvQkFDSWtHLGFBQWFSLEtBQUszRixLQUFLLEdBQUcyRixLQUFLbEIsa0JBQWtCLENBQUN6RSxLQUFLO29CQUN2RDtnQkFDSjtvQkFDSW1HLGFBQWE7WUFDckI7WUFFQSxNQUFNRSxnQkFBZ0IsQ0FDbEJDO2dCQU9BLDJCQUEyQjtnQkFDM0IsNkNBQTZDO2dCQUM3QywwRUFBMEU7Z0JBQzFFLHdFQUF3RTtnQkFDeEUsNkNBQTZDO2dCQUM3QyxPQUFRWCxLQUFLbkIsYUFBYTtvQkFDdEI7d0JBQ0ksT0FBTzs0QkFDSFAsS0FBSzBCLEtBQUsxQixHQUFHOzRCQUNiQyxNQUFNeUIsS0FBS3pCLElBQUk7NEJBQ2ZqRSxRQUFRcUc7NEJBQ1J0RyxPQUFPMkYsS0FBSzNGLEtBQUs7d0JBQ3JCO29CQUNKO3dCQUNJLE9BQU87NEJBQ0hpRSxLQUNJMEIsS0FBSzFCLEdBQUcsR0FDUjBCLEtBQUsxRixNQUFNLEdBQ1gwRixLQUFLbEIsa0JBQWtCLENBQUN4RSxNQUFNLEdBQzlCcUc7NEJBQ0pwQyxNQUFNeUIsS0FBS3pCLElBQUk7NEJBQ2ZqRSxRQUFRMEYsS0FBS2xCLGtCQUFrQixDQUFDeEUsTUFBTSxHQUFHcUc7NEJBQ3pDdEcsT0FBTzJGLEtBQUszRixLQUFLO3dCQUNyQjtvQkFDSjt3QkFDSSxPQUFPOzRCQUNIaUUsS0FBSzBCLEtBQUsxQixHQUFHOzRCQUNiQyxNQUNJeUIsS0FBS3pCLElBQUksR0FDVHlCLEtBQUszRixLQUFLLEdBQ1YyRixLQUFLbEIsa0JBQWtCLENBQUN6RSxLQUFLLEdBQzdCc0c7NEJBQ0pyRyxRQUFRMEYsS0FBSzFGLE1BQU07NEJBQ25CRCxPQUFPMkYsS0FBS2xCLGtCQUFrQixDQUFDekUsS0FBSyxHQUFHc0c7d0JBQzNDO29CQUNKO3dCQUNJLE9BQU87NEJBQ0hyQyxLQUFLMEIsS0FBSzFCLEdBQUc7NEJBQ2JDLE1BQU15QixLQUFLekIsSUFBSTs0QkFDZmpFLFFBQVEwRixLQUFLMUYsTUFBTTs0QkFDbkJELE9BQU9zRzt3QkFDWDtvQkFDSjt3QkFDSSxPQUFPOzRCQUNIckMsS0FBSzs0QkFDTEMsTUFBTTs0QkFDTmpFLFFBQVE7NEJBQ1JELE9BQU87d0JBQ1g7Z0JBQ1I7WUFDSjtZQUVBLE1BQU11RyxPQUFPLENBQUNDO2dCQUNWLElBQUksQ0FBQyxJQUFJLENBQUNySCxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUNHLGdCQUFnQixFQUFFO29CQUN6Q21ILHFCQUFxQkw7b0JBQ3JCSixPQUFPO29CQUNQO2dCQUNKO2dCQUVBLElBQUksQ0FBQ0UsZ0JBQWdCO29CQUNqQkEsaUJBQWlCTTtnQkFDckI7Z0JBQ0EsTUFBTUUsVUFBVUYsWUFBWU47Z0JBQzVCLE1BQU1TLG1CQUFtQkQsVUFBVTlIO2dCQUNuQyxNQUFNMEgsWUFBWUgsYUFBYTlGLEtBQUtNLEdBQUcsQ0FBQ2dHLGtCQUFrQjtnQkFDMUQsTUFBTUMsZ0JBQWdCUCxjQUFjQztnQkFDcEMsSUFBSSxDQUFDbkgsT0FBTyxDQUFDMEgsUUFBUSxDQUNqQkQsY0FBYzFDLElBQUksRUFDbEIwQyxjQUFjM0MsR0FBRyxFQUNqQjJDLGNBQWM1RyxLQUFLLEVBQ25CNEcsY0FBYzNHLE1BQU07Z0JBRXhCLElBQUl5RyxXQUFXOUgsVUFBVTtvQkFDckJtSCxRQUFRO2dCQUNaLE9BQU87b0JBQ0hLLG1CQUFtQjFHLE9BQU9vSCxxQkFBcUIsQ0FBQ1A7Z0JBQ3BEO1lBQ0o7WUFFQUgsbUJBQW1CMUcsT0FBT29ILHFCQUFxQixDQUFDUDtZQUVoRCxtQ0FBbUM7WUFDbkMsT0FBTztnQkFDSCxJQUFJSCxrQkFBa0I7b0JBQ2xCSyxxQkFBcUJMO2dCQUN6QjtZQUNKO1FBQ0o7SUFDSjtJQUVRVyxlQUFlQyxLQUFhLEVBQVE7UUFDeEMsSUFBSSxDQUFDLElBQUksQ0FBQzdILE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQ0csZ0JBQWdCLEVBQUU7UUFFN0MsSUFBSSxDQUFDSCxPQUFPLENBQUM4RyxTQUFTLEdBQUcsSUFBSSxDQUFDNUUsZUFBZTtRQUM3QyxJQUFJNkU7UUFFSixNQUFNSyxPQUFPLENBQUNDO1lBQ1YsSUFBSSxDQUFDLElBQUksQ0FBQ3JILE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQ0csZ0JBQWdCLEVBQUU7WUFFN0MsSUFBSSxDQUFDNEcsZ0JBQWdCO2dCQUNqQkEsaUJBQWlCTTtZQUNyQjtZQUNBLE1BQU1FLFVBQVVGLFlBQVlOO1lBQzVCLE1BQU1TLG1CQUFtQkQsVUFBVU07WUFDbkMsTUFBTVYsWUFBWSxJQUFJLENBQUNsRCxTQUFTLEdBQUcvQyxLQUFLTSxHQUFHLENBQUNnRyxrQkFBa0I7WUFDOUQsSUFBSSxDQUFDeEgsT0FBTyxDQUFDMEgsUUFBUSxDQUFDLEdBQUcsR0FBR1AsV0FBVztZQUN2QyxJQUFJSSxXQUFXTSxPQUFPO2dCQUNsQjtZQUNKLE9BQU87Z0JBQ0h0SCxPQUFPb0gscUJBQXFCLENBQUNQO1lBQ2pDO1FBQ0o7UUFFQTdHLE9BQU9vSCxxQkFBcUIsQ0FBQ1A7SUFDakM7SUFFUVUsbUJBQW1CQyxLQUFhLEVBQVU7WUFNMUNBO1FBTEosZ0RBQWdEO1FBQ2hELElBQUlBLEtBQUssQ0FBQyxFQUFFLENBQUMzQyxRQUFRLENBQUNZLE1BQU0sR0FBRyxHQUFHO1lBQzlCK0IsS0FBSyxDQUFDLEVBQUUsQ0FBQzNDLFFBQVEsR0FBRyxJQUFJLENBQUMwQyxrQkFBa0IsQ0FBQ0MsS0FBSyxDQUFDLEVBQUUsQ0FBQzNDLFFBQVE7WUFDN0QsT0FBTzJDO1FBQ1g7UUFDQSxJQUFJQSxFQUFBQSxVQUFBQSxLQUFLLENBQUMsRUFBRSxjQUFSQSw4QkFBQUEsUUFBVTNDLFFBQVEsQ0FBQ1ksTUFBTSxJQUFHLEdBQUc7WUFDL0IrQixLQUFLLENBQUMsRUFBRSxDQUFDM0MsUUFBUSxHQUFHLElBQUksQ0FBQzBDLGtCQUFrQixDQUFDQyxLQUFLLENBQUMsRUFBRSxDQUFDM0MsUUFBUTtZQUM3RCxPQUFPMkM7UUFDWDtRQUNBLElBQUlBLE1BQU0vQixNQUFNLEtBQUssS0FBSytCLEtBQUssQ0FBQyxFQUFFLENBQUMzQyxRQUFRLENBQUNZLE1BQU0sS0FBSyxHQUFHO1lBQ3RELE9BQU8sRUFBRTtRQUNiO1FBQ0EsTUFBTU0sV0FDRnlCLEtBQUssQ0FBQyxFQUFFLENBQUNqRCxHQUFHLEtBQUtpRCxLQUFLLENBQUMsRUFBRSxDQUFDakQsR0FBRztRQUNqQyxNQUFNa0QsU0FBUzlHLEtBQUtFLE1BQU07UUFDMUIsTUFBTTZHLFdBQVdGLE1BQ1pHLE1BQU0sQ0FBQyxDQUFDQyxPQUFPdEQ7WUFDWixJQUFJbUQsU0FBUyxPQUFPbkQsVUFBVSxHQUFHO2dCQUM3QixPQUFPO1lBQ1g7WUFDQSxJQUFJbUQsVUFBVSxPQUFPbkQsVUFBVSxHQUFHO2dCQUM5QixPQUFPO1lBQ1g7WUFDQSxPQUFPO1FBQ1gsR0FDQ0YsR0FBRyxDQUFDLENBQUM2QjtZQUNGLG1EQUFtRDtZQUNuRCxrQ0FBa0M7WUFDbEMsbUNBQW1DO1lBQ25DLHFDQUFxQztZQUNyQyxNQUFNbkIsZ0JBQ0YyQyxTQUFTLE1BQ0h4QixLQUFLbkIsYUFBYSxHQUNsQmlCO1lBR1YsT0FBTztnQkFDSCxHQUFHRSxJQUFJO2dCQUNQckIsT0FBT3FCLEtBQUt0QixLQUFLLEdBQUcsSUFBSSxJQUFJLENBQUNoRCxlQUFlLEdBQUdzRSxLQUFLckIsS0FBSztnQkFDekRFO2dCQUNBQyxvQkFBb0I7b0JBQ2hCeEUsUUFBUTBGLEtBQUsxRixNQUFNO29CQUNuQkQsT0FBTzJGLEtBQUszRixLQUFLO2dCQUNyQjtZQUNKO1FBQ0o7UUFDSixJQUFJeUYsdUJBQThCO1lBQzlCMkIsUUFBUSxDQUFDLEVBQUUsQ0FBQ25ILE1BQU0sR0FBR2lILEtBQUssQ0FBQyxFQUFFLENBQUNqSCxNQUFNLEdBQUdpSCxLQUFLLENBQUMsRUFBRSxDQUFDakgsTUFBTTtZQUN0RCxJQUFJa0gsVUFBVSxLQUFLO2dCQUNmQyxRQUFRLENBQUMsRUFBRSxDQUFDbkQsR0FBRyxHQUFHaUQsS0FBSyxDQUFDLEVBQUUsQ0FBQ2pELEdBQUc7WUFDbEM7UUFDSjtRQUNBLElBQUl3QixvQkFBMkI7WUFDM0IyQixRQUFRLENBQUMsRUFBRSxDQUFDcEgsS0FBSyxHQUFHa0gsS0FBSyxDQUFDLEVBQUUsQ0FBQ2xILEtBQUssR0FBR2tILEtBQUssQ0FBQyxFQUFFLENBQUNsSCxLQUFLO1lBQ25ELElBQUltSCxVQUFVLEtBQUs7Z0JBQ2ZDLFFBQVEsQ0FBQyxFQUFFLENBQUNsRCxJQUFJLEdBQUdnRCxLQUFLLENBQUMsRUFBRSxDQUFDaEQsSUFBSTtZQUNwQztRQUNKO1FBQ0Esa0JBQWtCO1FBQ2xCLElBQUksQ0FBQ3RFLFFBQVEsQ0FBQ3VDLElBQUksQ0FBQ2lGLFFBQVEsQ0FBQyxFQUFFO1FBQzlCLE9BQU9BO0lBQ1g7SUFFUUcsY0FBb0I7WUFLakJDO1FBSlAsSUFBSSxDQUFDLElBQUksQ0FBQ2xJLGdCQUFnQixFQUFFO1FBRTVCLE1BQU1rSSxXQUFXLElBQUksQ0FBQzVILFFBQVEsQ0FBQyxFQUFFO1FBQ2pDLElBQUksQ0FBQ0EsUUFBUSxHQUFHLEVBQUU7UUFDbEIsTUFBTzRILENBQUFBLHFCQUFBQSxnQ0FBQUEscUJBQUFBLFNBQVVqRCxRQUFRLGNBQWxCaUQseUNBQUFBLG1CQUFvQnJDLE1BQU0sSUFBRyxFQUFHO1lBQ25DcUMsU0FBU2pELFFBQVEsR0FBRyxJQUFJLENBQUMwQyxrQkFBa0IsQ0FBQ08sU0FBU2pELFFBQVE7UUFDakU7UUFDQSxJQUFJLENBQUNrRCxXQUFXO0lBQ3BCO0lBRVFsSSxhQUFtQjtRQUN2QixJQUFJLENBQUMsSUFBSSxDQUFDSixPQUFPLElBQUksQ0FBQyxJQUFJLENBQUNHLGdCQUFnQixFQUFFO1FBRTdDLElBQUksQ0FBQ0gsT0FBTyxDQUFDOEcsU0FBUyxHQUFHLElBQUksQ0FBQzVFLGVBQWU7UUFDN0MsSUFBSSxDQUFDbEMsT0FBTyxDQUFDMEgsUUFBUSxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUN6RCxTQUFTLEVBQUUsSUFBSSxDQUFDRCxVQUFVO1FBRTNELElBQUksQ0FBQ0ssWUFBWSxHQUFHLElBQUksQ0FBQ0gsa0JBQWtCO1FBQzNDLElBQUksQ0FBQ3hELElBQUksR0FBRztZQUNSSSxRQUFRLElBQUksQ0FBQ2tELFVBQVU7WUFDdkJuRCxPQUFPLElBQUksQ0FBQ29ELFNBQVM7WUFDckJhLEtBQUs7WUFDTEMsTUFBTTtZQUNOSyxVQUFVLEVBQUU7WUFDWkYsT0FBTztZQUNQQyxPQUFPLElBQUksQ0FBQ2pELGVBQWU7WUFDM0JtRCxhQUFhO1lBQ2JDLG9CQUFvQjtnQkFDaEJ4RSxRQUFRLElBQUksQ0FBQ2tELFVBQVU7Z0JBQ3ZCbkQsT0FBTyxJQUFJLENBQUNvRCxTQUFTO1lBQ3pCO1FBQ0o7UUFDQSxJQUFJLENBQUN4RCxRQUFRLEdBQUcsRUFBRTtRQUNsQixJQUFJLENBQUM4RixZQUFZLENBQUMsSUFBSSxDQUFDN0YsSUFBSTtRQUMzQixJQUFJLENBQUM0SCxXQUFXO0lBQ3BCO0lBRVFDLFlBQWtCO1FBQ3RCLE1BQU1DLGdCQUFnQixJQUFJLENBQUN2RSxTQUFTLEdBQUcsSUFBSSxDQUFDRCxVQUFVO1FBQ3RELE1BQU15RSxnQkFBZ0IsSUFBSSxDQUFDaEksUUFBUSxDQUM5QnlILE1BQU0sQ0FBQyxDQUFDMUIsT0FBU0EsS0FBS3BCLFFBQVEsQ0FBQ1ksTUFBTSxLQUFLLEdBQzFDckIsR0FBRyxDQUFDLENBQUN5QixJQUFNQSxFQUFFdEYsTUFBTSxHQUFHc0YsRUFBRXZGLEtBQUssRUFDN0JvRSxNQUFNLENBQUMsSUFBSSxDQUFDOUMsR0FBRyxFQUFFO1FBQ3RCbEMsUUFBUXlJLElBQUksQ0FBQ0YsZUFBZUM7SUFDaEM7SUFFQSxNQUFjSCxjQUE2QjtRQUN2QyxJQUFJLENBQUMsSUFBSSxDQUFDbkksZ0JBQWdCLEVBQUU7UUFFNUIsSUFBSSxJQUFJLENBQUNNLFFBQVEsQ0FBQyxJQUFJLENBQUNvRSxLQUFLLENBQUMsRUFBRTtZQUMzQixJQUFJO2dCQUNBLE1BQU0sSUFBSSxDQUFDNkIsUUFBUSxDQUFDLElBQUksQ0FBQzdCLEtBQUs7Z0JBQzlCLElBQUksQ0FBQ0EsS0FBSztnQkFDVixJQUFJLElBQUksQ0FBQ0EsS0FBSyxHQUFHLElBQUksQ0FBQ3BFLFFBQVEsQ0FBQ3VGLE1BQU0sRUFBRTtvQkFDbkMsSUFBSSxJQUFJLENBQUM3RixnQkFBZ0IsRUFBRTt3QkFDdkIsd0VBQXdFO3dCQUN4RUksT0FBT29ILHFCQUFxQixDQUFDLElBQU0sSUFBSSxDQUFDVyxXQUFXO29CQUN2RDtnQkFDSixPQUFPO3dCQU1LLGlCQUdBO29CQVJSLElBQUksQ0FBQ3pELEtBQUssR0FBRztvQkFDYixrSEFBa0g7b0JBQ2xILG9EQUFvRDtvQkFDcEQsSUFDSTNELEtBQUt5SCxLQUFLLEVBQ04sc0JBQUksQ0FBQ2xJLFFBQVEsQ0FBQyxJQUFJLENBQUNBLFFBQVEsQ0FBQ3VGLE1BQU0sR0FBRyxFQUFFLGNBQXZDLHNEQUF5Q25GLEtBQUssTUFDNUMsSUFBSSxDQUFDb0QsU0FBUyxJQUNwQi9DLEtBQUt5SCxLQUFLLEVBQ04sdUJBQUksQ0FBQ2xJLFFBQVEsQ0FBQyxJQUFJLENBQUNBLFFBQVEsQ0FBQ3VGLE1BQU0sR0FBRyxFQUFFLGNBQXZDLHdEQUF5Q2xGLE1BQU0sTUFDN0MsSUFBSSxDQUFDa0QsVUFBVSxFQUN2Qjt3QkFDRSxJQUFJLENBQUM1RCxVQUFVO29CQUNuQixPQUFPO3dCQUNILElBQUksQ0FBQzZCLGVBQWU7d0JBQ3BCLElBQUksQ0FBQzNCLFNBQVMsR0FBR0MsT0FBT3FJLFVBQVUsQ0FBQzs0QkFDL0IsSUFBSSxJQUFJLENBQUN6SSxnQkFBZ0IsRUFBRTtnQ0FDdkIsSUFBSSxDQUFDaUksV0FBVzs0QkFDcEI7d0JBQ0osR0FBRztvQkFDUDtnQkFDSjtZQUNKLEVBQUUsT0FBT2xJLE9BQU87Z0JBQ1osaUZBQWlGO2dCQUNqRix1RUFBdUU7Z0JBQ3ZFLElBQUksSUFBSSxDQUFDQyxnQkFBZ0IsRUFBRTtvQkFDdkJGLFFBQVFDLEtBQUssQ0FBQyx5QkFBeUJBO2dCQUMzQztZQUNKO1FBQ0osT0FBTztZQUNILElBQUksQ0FBQzJFLEtBQUs7WUFDVixJQUFJLElBQUksQ0FBQ0EsS0FBSyxHQUFHLElBQUksQ0FBQ3BFLFFBQVEsQ0FBQ3VGLE1BQU0sSUFBSSxJQUFJLENBQUM3RixnQkFBZ0IsRUFBRTtnQkFDNURJLE9BQU9vSCxxQkFBcUIsQ0FBQyxJQUFNLElBQUksQ0FBQ1csV0FBVztZQUN2RDtRQUNKO0lBQ0o7SUFybkJBTyxZQUFZdEYsUUFBZ0IsQ0FBRTthQWZ0QnZELFVBQTJDO2FBQzNDVSxPQUFvQjthQUNwQkQsV0FBbUIsRUFBRTthQUNyQjRELGVBQW9DO2FBQ3BDUSxRQUFRO2FBQ1JiLGFBQWE7YUFDYkMsWUFBWTthQUNaeEMsV0FBNkI7WUFBQztZQUFHO1NBQUU7YUFDbkNNLGtCQUFvQztZQUFDO1lBQUc7U0FBRTthQUMxQ0MsaUJBQW1DO1lBQUM7WUFBRztTQUFFO2FBQ3pDRSxrQkFBa0I7YUFDbEJuQyxTQUFtQzthQUNuQ0ksbUJBQW1CO2FBQ25CRyxZQUEyQjtRQUcvQixJQUFJLENBQUNnRCxXQUFXLENBQUNDO1FBQ2pCLElBQUksQ0FBQ3RCLGVBQWU7SUFDeEI7QUFtbkJKO0FBRU8sTUFBTTZHLHNCQUFzQixDQUFDdkY7SUFDaEMsTUFBTXdGLFdBQVcsSUFBSWxKLGFBQWEwRDtJQUNsQ3dGLFNBQVNqSixLQUFLO0lBQ2QsT0FBT2lKO0FBQ1gsRUFBQyIsInNvdXJjZXMiOlsiL1VzZXJzL2plZmZmb2hsL2Rldi93ZWJzaXRlL2Zyb250ZW5kL2FuaW1hdGlvbnMvc2NyaXB0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIEFydCBpcyBhIGNvbnN0YW50IHByb2Nlc3Mgb2YgaW52ZW50aW5nIHdheXMgdG8gZXNjYXBlIHRoZSByZXN0cmljdGlvbnMgb2YgcGFzdCBpbnZlbnRpb25zLlxuICovXG5cbi8vIHR5cGVzXG5pbnRlcmZhY2UgR3JpZFNjYWZmb2xkIHtcbiAgICBjb2x1bW5zOiBudW1iZXJbXVxuICAgIHJvd3M6IG51bWJlcltdXG59XG5cbmVudW0gR3JpZFR5cGUge1xuICAgIFJPVyA9ICdyb3cnLFxuICAgIENPTFVNTiA9ICdjb2x1bW4nLFxufVxuaW50ZXJmYWNlIENlbGwge1xuICAgIGxlZnQ6IG51bWJlclxuICAgIHRvcDogbnVtYmVyXG4gICAgd2lkdGg6IG51bWJlclxuICAgIGhlaWdodDogbnVtYmVyXG4gICAgY29sb3I6IHN0cmluZ1xuICAgIGRlcHRoOiBudW1iZXJcbiAgICBjaGlsZHJlbjogQ2VsbFtdXG4gICAgZHJhd0RpcmVjdGlvbjogQ2VsbERyYXdEaXJlY3Rpb25cbiAgICBvcmlnaW5hbERpbWVuc2lvbnM6IHtcbiAgICAgICAgaGVpZ2h0OiBudW1iZXJcbiAgICAgICAgd2lkdGg6IG51bWJlclxuICAgIH1cbn1cblxuZW51bSBDZWxsRHJhd0RpcmVjdGlvbiB7XG4gICAgVVAgPSAndXAnLFxuICAgIERPV04gPSAnZG93bicsXG4gICAgTEVGVCA9ICdsZWZ0JyxcbiAgICBSSUdIVCA9ICdyaWdodCcsXG59XG5cbi8vIGNvbnN0YW50c1xuY29uc3QgU1dFRVRORVNTID0gMjRcbmNvbnN0IElOVEVSVkFMID0gMTAwXG5jb25zdCBIVUVfUkFOR0UgPSA0MFxuY29uc3QgU0FUVVJBVElPTl9SQU5HRSA9IDUwXG5jb25zdCBMSUdIVE5FU1NfUkFOR0UgPSA1MFxuXG5jbGFzcyBHcmlkQW5pbWF0b3Ige1xuICAgIHByaXZhdGUgY29udGV4dDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEIHwgbnVsbCA9IG51bGxcbiAgICBwcml2YXRlIGdyaWQ6IENlbGwgfCBudWxsID0gbnVsbFxuICAgIHByaXZhdGUgZmxhdEdyaWQ6IENlbGxbXSA9IFtdXG4gICAgcHJpdmF0ZSBncmlkU2NhZmZvbGQ6IEdyaWRTY2FmZm9sZCB8IG51bGwgPSBudWxsXG4gICAgcHJpdmF0ZSBpbmRleCA9IDBcbiAgICBwcml2YXRlIGdyaWRIZWlnaHQgPSAwXG4gICAgcHJpdmF0ZSBncmlkV2lkdGggPSAwXG4gICAgcHJpdmF0ZSBodWVDbGFtcDogW251bWJlciwgbnVtYmVyXSA9IFswLCAwXVxuICAgIHByaXZhdGUgc2F0dXJhdGlvbkNsYW1wOiBbbnVtYmVyLCBudW1iZXJdID0gWzAsIDBdXG4gICAgcHJpdmF0ZSBsaWdodG5lc3NDbGFtcDogW251bWJlciwgbnVtYmVyXSA9IFswLCAwXVxuICAgIHByaXZhdGUgYmFja2dyb3VuZENvbG9yID0gJydcbiAgICBwcml2YXRlIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQgfCBudWxsID0gbnVsbFxuICAgIHByaXZhdGUgYW5pbWF0aW9uUnVubmluZyA9IGZhbHNlXG4gICAgcHJpdmF0ZSB0aW1lb3V0SWQ6IG51bWJlciB8IG51bGwgPSBudWxsXG5cbiAgICBjb25zdHJ1Y3RvcihjYW52YXNJZDogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuc2V0dXBDYW52YXMoY2FudmFzSWQpXG4gICAgICAgIHRoaXMuZ2VuZXJhdGVQYWxldHRlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgYW5pbWF0aW9uIG9uIHRoZSBzcGVjaWZpZWQgY2FudmFzXG4gICAgICovXG4gICAgcHVibGljIHN0YXJ0KCk6IHZvaWQge1xuICAgICAgICBpZiAoIXRoaXMuY2FudmFzIHx8ICF0aGlzLmNvbnRleHQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0NhbnZhcyBub3QgYXZhaWxhYmxlJylcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5hbmltYXRpb25SdW5uaW5nID0gdHJ1ZVxuICAgICAgICB0aGlzLmNyZWF0ZUdyaWQoKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0b3BzIGFuaW1hdGlvbiBhbmQgY2xlYW5zIHVwIHJlc291cmNlc1xuICAgICAqL1xuICAgIHB1YmxpYyBzdG9wKCk6IHZvaWQge1xuICAgICAgICAvLyBTZXQgZmxhZyBmaXJzdCB0byBzdG9wIGFueSBuZXcgYW5pbWF0aW9ucyBmcm9tIHN0YXJ0aW5nXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uUnVubmluZyA9IGZhbHNlXG5cbiAgICAgICAgLy8gQ2xlYXIgYW55IHRpbWVvdXRzXG4gICAgICAgIGlmICh0aGlzLnRpbWVvdXRJZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRJZClcbiAgICAgICAgICAgIHRoaXMudGltZW91dElkID0gbnVsbFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2xlYW4gdXAgZGF0YSB0aGF0IG1pZ2h0IGJlIGhvbGRpbmcgcmVmZXJlbmNlc1xuICAgICAgICB0aGlzLmZsYXRHcmlkID0gW11cbiAgICAgICAgdGhpcy5ncmlkID0gbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFuIHVwIHJlc291cmNlcyB3aGVuIGNvbXBvbmVudCB1bm1vdW50c1xuICAgICAqL1xuICAgIHB1YmxpYyBkZXN0cm95KCk6IHZvaWQge1xuICAgICAgICAvLyBTdG9wIHRoZSBhbmltYXRpb24gZmlyc3RcbiAgICAgICAgdGhpcy5zdG9wKClcblxuICAgICAgICAvLyBSZWxlYXNlIHJlZmVyZW5jZXMgdG8gRE9NIGVsZW1lbnRzXG4gICAgICAgIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgICAgICAgLy8gQ2xlYXIgdGhlIGNhbnZhcyB0byBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5jbGVhclJlY3QoXG4gICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5oZWlnaHRcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhbnZhcyA9IG51bGxcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gbnVsbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIHJhbmRvbSB3aW5kb3cgb2YgZ2l2ZW4gcmFuZ2Ugd2l0aGluIGdpdmVuIGRvbWFpblxuICAgICAqIEBwYXJhbSBkb21haW4gdGhlIG1heGltdW0gKGFzc3VtaW5nIGFsbCBkb21haW5zIHN0YXJ0IHdpdGggMClcbiAgICAgKiBAcGFyYW0gcmFuZ2UgdGhlIGxlbmd0aCBvZiB0aGUgd2luZG93XG4gICAgICovXG4gICAgcHJpdmF0ZSBnZW5lcmF0ZUNsYW1wKGRvbWFpbjogbnVtYmVyLCByYW5nZTogbnVtYmVyKTogW251bWJlciwgbnVtYmVyXSB7XG4gICAgICAgIC8vIGdlbmVyYXRlIHJhbmRvbSBzdGFydGluZyBwb2ludCwgYmFzZWQgb24gZG9tYWluIG1pbnVzIHRoZSByYW5nZS4gZS5nLiB3aXRoIGEgZG9tYWluIG9mIDAgdG8gMzYwLFxuICAgICAgICAvLyBhbmQgdGhlIHJhbmdlIGlzIDUwLCB0aGVuIHdlIGNob29zZSBhIHN0YXJ0aW5nIG51bWJlciBiZXR3ZWVuIDAgYW5kIDMxMC5cbiAgICAgICAgLy8gdGhpcyBpcyB0aGUgYmVnaW5uaW5nIG9mIHRoZSBjbGFtcC5cbiAgICAgICAgY29uc3Qgc3RhcnQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoZG9tYWluIC0gcmFuZ2UpKVxuICAgICAgICByZXR1cm4gW3N0YXJ0LCBzdGFydCArIHJhbmdlXVxuICAgIH1cblxuICAgIHByaXZhdGUgZ2VuZXJhdGVDaXJjdWxhckNsYW1wKFxuICAgICAgICBkb21haW46IG51bWJlcixcbiAgICAgICAgcmFuZ2U6IG51bWJlclxuICAgICk6IFtudW1iZXIsIG51bWJlcl0ge1xuICAgICAgICAvLyBiZWNhdXNlIGh1ZSBpcyBhIGNpcmN1bGFyIHJhbmdlIC0gZ29pbmcgZnJvbSAwIHRvIDM2MCwgd2UgY291bGQgaGF2ZSBhIGNsYW1wXG4gICAgICAgIC8vIHdoaWNoIHN0YXJ0cyBhdCAzMDAsIGFuZCBlbmRzIGF0IDQwLiBTbywgYW55IG51bWJlciBhYm92ZSAzMDAgb3IgYmVsb3cgNDAgd291bGRcbiAgICAgICAgLy8gYmUgYSB2YWxpZCB2YWx1ZSBpbiB0aGlzIHJhbmdlLlxuICAgICAgICBjb25zdCBzdGFydCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGRvbWFpbilcbiAgICAgICAgbGV0IGVuZCA9IHN0YXJ0ICsgcmFuZ2VcbiAgICAgICAgaWYgKGVuZCA+IGRvbWFpbikge1xuICAgICAgICAgICAgZW5kID0gc3RhcnQgKyByYW5nZSAtIGRvbWFpblxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbc3RhcnQsIGVuZF1cbiAgICB9XG5cbiAgICBwcml2YXRlIGdldFJhbmRvbUh1ZSgpOiBudW1iZXIge1xuICAgICAgICBjb25zdCBtaW4gPSB0aGlzLmh1ZUNsYW1wWzBdXG4gICAgICAgIGNvbnN0IG1heCA9XG4gICAgICAgICAgICB0aGlzLmh1ZUNsYW1wWzFdIDwgdGhpcy5odWVDbGFtcFswXVxuICAgICAgICAgICAgICAgID8gMzYwICsgdGhpcy5odWVDbGFtcFsxXVxuICAgICAgICAgICAgICAgIDogdGhpcy5odWVDbGFtcFsxXVxuICAgICAgICBjb25zdCB2YWx1ZSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4pICsgbWluKVxuICAgICAgICByZXR1cm4gdmFsdWUgPiAzNjAgPyB2YWx1ZSAtIDM2MCA6IHZhbHVlXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRSYW5kb21DbGFtcGVkKG1pbjogbnVtYmVyLCBtYXg6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIG1pbiA9IE1hdGguY2VpbChtaW4pXG4gICAgICAgIG1heCA9IE1hdGguZmxvb3IobWF4KVxuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbikgKyBtaW4pXG4gICAgfVxuXG4gICAgcHJpdmF0ZSByYW5kb21Db2xvcigpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gYGhzbCgke3RoaXMuZ2V0UmFuZG9tSHVlKCl9ICR7dGhpcy5nZXRSYW5kb21DbGFtcGVkKFxuICAgICAgICAgICAgdGhpcy5zYXR1cmF0aW9uQ2xhbXBbMF0sXG4gICAgICAgICAgICB0aGlzLnNhdHVyYXRpb25DbGFtcFsxXVxuICAgICAgICApfSUgJHt0aGlzLmdldFJhbmRvbUNsYW1wZWQoXG4gICAgICAgICAgICB0aGlzLmxpZ2h0bmVzc0NsYW1wWzBdLFxuICAgICAgICAgICAgdGhpcy5saWdodG5lc3NDbGFtcFsxXVxuICAgICAgICApfSUpYFxuICAgIH1cblxuICAgIHByaXZhdGUgZ2VuZXJhdGVQYWxldHRlKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmh1ZUNsYW1wID0gdGhpcy5nZW5lcmF0ZUNpcmN1bGFyQ2xhbXAoMzYwLCBIVUVfUkFOR0UpXG4gICAgICAgIHRoaXMuc2F0dXJhdGlvbkNsYW1wID0gdGhpcy5nZW5lcmF0ZUNsYW1wKDEwMCwgU0FUVVJBVElPTl9SQU5HRSlcbiAgICAgICAgdGhpcy5saWdodG5lc3NDbGFtcCA9IHRoaXMuZ2VuZXJhdGVDbGFtcCgxMDAsIExJR0hUTkVTU19SQU5HRSlcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLnJhbmRvbUNvbG9yKClcbiAgICB9XG5cbiAgICBwcml2YXRlIHN1bShwYXJ0aWFsU3VtOiBudW1iZXIsIGE6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIHJldHVybiBwYXJ0aWFsU3VtICsgYVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIGZvciBnZW5lcmF0aW5nIGEgcmFuZG9tIG51bWJlciwgd2l0aCBhbiB1cHBlciBib3VuZFxuICAgICAqIGRldGVybWluZWQgYnkgYSBkaW1pbmlzaGluZyBwcm9iYWJpbGl0eS5cbiAgICAgKiBAcGFyYW0gc3dlZXRuZXNzIFRoaXMgcGFyYW1ldGVyIGRldGVybWluZXMgaG93IGxpa2VseSB0aGUgcmFuZG9tIG51bWJlciBpcyB0byBiZSBsYXJnZS5cbiAgICAgKiBMb3dlciBudW1iZXJzIHJlZHVjZSB0aGUgcHJvYmFiaWxpdHksIGxhcmdlciBudW1iZXJzIGluY3JlYXNlIHRoZSBwcm9iYWJpbGl0eS5cbiAgICAgKi9cbiAgICBwcml2YXRlIGdldFZhbHVlKHN3ZWV0OiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICBsZXQgY291bnQgPSAwXG4gICAgICAgIGxldCBjb2VmZmljaWVudCA9IDEgLyBzd2VldFxuICAgICAgICBsZXQgcHJvZ3Jlc3MgPSBmYWxzZVxuICAgICAgICB3aGlsZSAoIXByb2dyZXNzKSB7XG4gICAgICAgICAgICBpZiAoTWF0aC5yYW5kb20oKSA8PSBjb2VmZmljaWVudCkge1xuICAgICAgICAgICAgICAgIHByb2dyZXNzID0gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY291bnQrK1xuICAgICAgICAgICAgY29lZmZpY2llbnQgPSBjb2VmZmljaWVudCArIDEgLyBzd2VldFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb3VudFxuICAgIH1cblxuICAgIHByaXZhdGUgY3JlYXRlU3ByZWFkKGNvdW50OiBudW1iZXIpOiBudW1iZXJbXSB7XG4gICAgICAgIGNvbnN0IHNwcmVhZCA9IFtdXG4gICAgICAgIGxldCByZW1haW5pbmcgPSAxXG4gICAgICAgIC8vIENyZWF0ZSA0IHJhbmRvbSBudW1iZXJzIGJldHdlZW4gMCBhbmQgMSBhbmQgc29ydCB0aGVtXG4gICAgICAgIGNvbnN0IHJhbmRvbVBvaW50cyA9IFtdXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQgLSAxOyBpKyspIHtcbiAgICAgICAgICAgIHJhbmRvbVBvaW50cy5wdXNoKE1hdGgucmFuZG9tKCkpXG4gICAgICAgIH1cbiAgICAgICAgcmFuZG9tUG9pbnRzLnNvcnQoKGEsIGIpID0+IGEgLSBiKVxuICAgICAgICAvLyBVc2UgdGhlc2UgcmFuZG9tIHBvaW50cyB0byBjcmVhdGUgNSByYW5kb20gY2h1bmtzXG4gICAgICAgIGxldCBwcmV2aW91c1BvaW50ID0gMFxuICAgICAgICBmb3IgKGNvbnN0IHBvaW50IG9mIHJhbmRvbVBvaW50cykge1xuICAgICAgICAgICAgY29uc3QgY2h1bmtTaXplID0gcG9pbnQgLSBwcmV2aW91c1BvaW50XG4gICAgICAgICAgICBzcHJlYWQucHVzaChjaHVua1NpemUpXG4gICAgICAgICAgICByZW1haW5pbmcgLT0gY2h1bmtTaXplXG4gICAgICAgICAgICBwcmV2aW91c1BvaW50ID0gcG9pbnRcbiAgICAgICAgfVxuICAgICAgICBzcHJlYWQucHVzaChyZW1haW5pbmcpIC8vIExhc3QgY2h1bmsgaXMgd2hhdGV2ZXIgaXMgcmVtYWluaW5nXG4gICAgICAgIHJldHVybiBzcHJlYWRcbiAgICB9XG5cbiAgICBwcml2YXRlIHNldHVwQ2FudmFzKGNhbnZhc0lkOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5jYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcbiAgICAgICAgICAgIGNhbnZhc0lkXG4gICAgICAgICkgYXMgSFRNTENhbnZhc0VsZW1lbnQgfCBudWxsXG4gICAgICAgIGlmICh0aGlzLmNhbnZhcz8uZ2V0Q29udGV4dCkge1xuICAgICAgICAgICAgY29uc3QgZHByID0gd2luZG93LmRldmljZVBpeGVsUmF0aW9cbiAgICAgICAgICAgIGNvbnN0IHJlY3QgPSB0aGlzLmNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgICAgICAgdGhpcy5jYW52YXMud2lkdGggPSByZWN0LndpZHRoICogZHByXG4gICAgICAgICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSByZWN0LmhlaWdodCAqIGRwclxuICAgICAgICAgICAgdGhpcy5jb250ZXh0ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKVxuICAgICAgICAgICAgdGhpcy5jb250ZXh0Py5zY2FsZShkcHIsIGRwcilcbiAgICAgICAgICAgIHRoaXMuZ3JpZEhlaWdodCA9IHJlY3QuaGVpZ2h0XG4gICAgICAgICAgICB0aGlzLmdyaWRXaWR0aCA9IHJlY3Qud2lkdGhcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgY3JlYXRlR3JpZFNjYWZmb2xkKCk6IEdyaWRTY2FmZm9sZCB7XG4gICAgICAgIGNvbnN0IGNvbHVtbkxlbmd0aCA9IHRoaXMuZ2V0VmFsdWUoU1dFRVRORVNTKVxuICAgICAgICBjb25zdCByb3dMZW5ndGggPSB0aGlzLmdldFZhbHVlKFNXRUVUTkVTUylcbiAgICAgICAgY29uc3QgZ3JpZFNjYWZmb2xkID0ge1xuICAgICAgICAgICAgY29sdW1uczogdGhpcy5jcmVhdGVTcHJlYWQoY29sdW1uTGVuZ3RoKSxcbiAgICAgICAgICAgIHJvd3M6IHRoaXMuY3JlYXRlU3ByZWFkKHJvd0xlbmd0aCksXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdyaWRTY2FmZm9sZFxuICAgIH1cblxuICAgIHByaXZhdGUgY2hvb3NlR3JpZFR5cGUoKTogR3JpZFR5cGUge1xuICAgICAgICByZXR1cm4gTWF0aC5yYW5kb20oKSA+PSAwLjUgPyBHcmlkVHlwZS5ST1cgOiBHcmlkVHlwZS5DT0xVTU5cbiAgICB9XG5cbiAgICBwcml2YXRlIGdlbmVyYXRlUm93KHBhcmVudENlbGw6IENlbGwsIGNvbHVtbnM6IG51bWJlcltdKTogQ2VsbFtdIHtcbiAgICAgICAgcmV0dXJuIGNvbHVtbnMubWFwKChjb2x1bW46IG51bWJlciwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gcGFyZW50Q2VsbC53aWR0aCAqIGNvbHVtblxuICAgICAgICAgICAgY29uc3QgdG9wID0gcGFyZW50Q2VsbC50b3BcbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPVxuICAgICAgICAgICAgICAgIGNvbHVtbnMuc2xpY2UoMCwgaW5kZXgpLnJlZHVjZSh0aGlzLnN1bSwgMCkgKiBwYXJlbnRDZWxsLndpZHRoICtcbiAgICAgICAgICAgICAgICBwYXJlbnRDZWxsLmxlZnRcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbGVmdCxcbiAgICAgICAgICAgICAgICB0b3AsXG4gICAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAgICAgZGVwdGg6IHBhcmVudENlbGwuZGVwdGggKyAxLFxuICAgICAgICAgICAgICAgIGhlaWdodDogcGFyZW50Q2VsbC5oZWlnaHQsXG4gICAgICAgICAgICAgICAgY29sb3I6IHRoaXMucmFuZG9tQ29sb3IoKSxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgICAgICAgICAgZHJhd0RpcmVjdGlvbjogQ2VsbERyYXdEaXJlY3Rpb24uUklHSFQsXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxEaW1lbnNpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICBwcml2YXRlIGdlbmVyYXRlQ29sdW1uKHBhcmVudENlbGw6IENlbGwsIHJvd3M6IG51bWJlcltdKTogQ2VsbFtdIHtcbiAgICAgICAgcmV0dXJuIHJvd3MubWFwKChyb3c6IG51bWJlciwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IHBhcmVudENlbGwuaGVpZ2h0ICogcm93XG4gICAgICAgICAgICBjb25zdCBsZWZ0ID0gcGFyZW50Q2VsbC5sZWZ0XG4gICAgICAgICAgICBjb25zdCB0b3AgPVxuICAgICAgICAgICAgICAgIHJvd3Muc2xpY2UoMCwgaW5kZXgpLnJlZHVjZSh0aGlzLnN1bSwgMCkgKiBwYXJlbnRDZWxsLmhlaWdodCArXG4gICAgICAgICAgICAgICAgcGFyZW50Q2VsbC50b3BcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbGVmdCxcbiAgICAgICAgICAgICAgICB0b3AsXG4gICAgICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgICAgIGRlcHRoOiBwYXJlbnRDZWxsLmRlcHRoICsgMSxcbiAgICAgICAgICAgICAgICB3aWR0aDogcGFyZW50Q2VsbC53aWR0aCxcbiAgICAgICAgICAgICAgICBjb2xvcjogdGhpcy5yYW5kb21Db2xvcigpLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgICAgICAgICAgICBkcmF3RGlyZWN0aW9uOiBDZWxsRHJhd0RpcmVjdGlvbi5ET1dOLFxuICAgICAgICAgICAgICAgIG9yaWdpbmFsRGltZW5zaW9uczoge1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRMZXZlbDJDb2x1bW5zKCk6IG51bWJlcltdIHtcbiAgICAgICAgaWYgKCF0aGlzLmdyaWRTY2FmZm9sZCkgcmV0dXJuIFtdXG5cbiAgICAgICAgLy8gd2UgYWRkIGEgbGl0dGxlIGV4dHJhIHNwaWNpbmVzcyB0byB0aGUgY29sdW1ucyBmb3IgZnVuOlxuICAgICAgICBjb25zdCBicmVha291dENoYW5jZSA9IDAuMDEgKiBTV0VFVE5FU1NcbiAgICAgICAgY29uc3Qgc2tpcENlbGxzOiBudW1iZXJbXSA9IFtdXG4gICAgICAgIGNvbnN0IG5ld0NvbHVtbnM6IG51bWJlcltdID0gW11cbiAgICAgICAgdGhpcy5ncmlkU2NhZmZvbGQuY29sdW1ucy5mb3JFYWNoKChjb2x1bW4sIGNvbHVtbkluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAoc2tpcENlbGxzLmluY2x1ZGVzKGNvbHVtbkluZGV4KSkge1xuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbHVtbkluZGV4ICsgMSA9PT0gdGhpcy5ncmlkU2NhZmZvbGQhLmNvbHVtbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbmV3Q29sdW1ucy5wdXNoKGNvbHVtbilcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGZvciBlYWNoIGNlbGwsIGRldGVybWluZSBpZiBpdCB3aWxsIGJyZWFrIG91dFxuICAgICAgICAgICAgLy8gaWYgaXQgZG9lcyBicmVhayBvdXQsIGRldGVybWluZSBob3cgbWFueSBjZWxscyB0byBicmVhayBvdXRcbiAgICAgICAgICAgIGlmIChNYXRoLnJhbmRvbSgpIDwgYnJlYWtvdXRDaGFuY2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBudW1iZXJPZlJlbWFpbmluZ0NvbHVtbnMgPVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdyaWRTY2FmZm9sZCEuY29sdW1ucy5sZW5ndGggLSAoY29sdW1uSW5kZXggKyAxKVxuICAgICAgICAgICAgICAgIC8vIHJhbmRvbWx5IHNlbGVjdCB0aGUgbnVtYmVyIG9mIGNvbHVtbnMgd2Ugd2FudCB0byBzcGFuIHRvIHRoZSByaWdodFxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbHVtblNwYW4gPSBNYXRoLmNlaWwoXG4gICAgICAgICAgICAgICAgICAgIE1hdGgucmFuZG9tKCkgKiBudW1iZXJPZlJlbWFpbmluZ0NvbHVtbnNcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3Q29sdW1uID0gdGhpcy5ncmlkU2NhZmZvbGQhLmNvbHVtbnMuc2xpY2UoXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbkluZGV4LFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW5JbmRleCArIGNvbHVtblNwYW5cbiAgICAgICAgICAgICAgICApLnJlZHVjZSh0aGlzLnN1bSwgMClcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IGNvbHVtblNwYW4gLSAxOyBjKyspIHtcbiAgICAgICAgICAgICAgICAgICAgc2tpcENlbGxzLnB1c2goYyArIGNvbHVtbkluZGV4ICsgMSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV3Q29sdW1ucy5wdXNoKG5ld0NvbHVtbilcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3Q29sdW1ucy5wdXNoKGNvbHVtbilcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgcmV0dXJuIG5ld0NvbHVtbnNcbiAgICB9XG5cbiAgICBwcml2YXRlIGdlbmVyYXRlQ2hpbGRyZW4ocGFyZW50Q2VsbDogQ2VsbCk6IENlbGxbXSB7XG4gICAgICAgIGlmICghdGhpcy5ncmlkU2NhZmZvbGQpIHJldHVybiBbXVxuXG4gICAgICAgIC8vIERlcHRoIGxldmVsIDAgaXMgdGhlIHRvcCBsZXZlbCBncmlkIGNlbGwgLSB0aGVyZSBjYW4gYmUgb25seSBvbmUhXG4gICAgICAgIC8vIERlcHRoIGxldmVsIDEgYXJlIHRoZSBjZWxscyBvZiB0aGF0IG1ha2UgdXAgdGhlIHRvcCByb3dzXG4gICAgICAgIC8vIERlcHRoIGxldmVsIDIgYXJlIHRoZSBjZWxscyB0aGF0IG1ha2UgdXAgdGhlIGNvbHVtbnNcbiAgICAgICAgLy8gQmVsb3cgbGV2ZWwgMiBjaGlsZHJlbiBkbyBub3QgYWRoZXJlIHRvIHRoZSBncmlkIHNjYWZmb2xkXG4gICAgICAgIGlmIChwYXJlbnRDZWxsLmRlcHRoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZUNvbHVtbihwYXJlbnRDZWxsLCB0aGlzLmdyaWRTY2FmZm9sZC5yb3dzKVxuICAgICAgICB9IGVsc2UgaWYgKHBhcmVudENlbGwuZGVwdGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlUm93KHBhcmVudENlbGwsIHRoaXMuZ2V0TGV2ZWwyQ29sdW1ucygpKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZ3JpZFR5cGUgPSB0aGlzLmNob29zZUdyaWRUeXBlKClcbiAgICAgICAgICAgIGNvbnN0IHNwcmVhZCA9IHRoaXMuY3JlYXRlU3ByZWFkKHRoaXMuZ2V0VmFsdWUoU1dFRVRORVNTKSlcbiAgICAgICAgICAgIHJldHVybiBncmlkVHlwZSA9PT0gR3JpZFR5cGUuQ09MVU1OXG4gICAgICAgICAgICAgICAgPyB0aGlzLmdlbmVyYXRlQ29sdW1uKHBhcmVudENlbGwsIHNwcmVhZClcbiAgICAgICAgICAgICAgICA6IHRoaXMuZ2VuZXJhdGVSb3cocGFyZW50Q2VsbCwgc3ByZWFkKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZW5lcmF0ZUdyaWQoY2VsbDogQ2VsbCk6IHZvaWQge1xuICAgICAgICB0aGlzLmZsYXRHcmlkLnB1c2goY2VsbClcbiAgICAgICAgaWYgKGNlbGwuZGVwdGggPCAyKSB7XG4gICAgICAgICAgICBjZWxsLmNoaWxkcmVuID0gdGhpcy5nZW5lcmF0ZUNoaWxkcmVuKGNlbGwpXG4gICAgICAgICAgICBjZWxsLmNoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUdyaWQoY2hpbGQpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2UgaWYgKGNlbGwuZGVwdGggPCA0KSB7XG4gICAgICAgICAgICBpZiAoTWF0aC5yYW5kb20oKSA8IDAuMDA3NSAqIFNXRUVUTkVTUykge1xuICAgICAgICAgICAgICAgIGNlbGwuY2hpbGRyZW4gPSB0aGlzLmdlbmVyYXRlQ2hpbGRyZW4oY2VsbClcbiAgICAgICAgICAgICAgICBjZWxsLmNoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVHcmlkKGNoaWxkKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGRyYXdDZWxsKGluZGV4OiBudW1iZXIpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jb250ZXh0IHx8ICF0aGlzLmFuaW1hdGlvblJ1bm5pbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGZhbHNlKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZmxhdEdyaWRbaW5kZXhdLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh0cnVlKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBjZWxsID0gdGhpcy5mbGF0R3JpZFtpbmRleF1cbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5maWxsU3R5bGUgPSBjZWxsLmNvbG9yXG4gICAgICAgICAgICBsZXQgc3RhcnRUaW1lc3RhbXA6IG51bWJlclxuICAgICAgICAgICAgbGV0IGxpbWl0VmFsdWU6IG51bWJlclxuICAgICAgICAgICAgbGV0IGFuaW1hdGlvbkZyYW1lSWQ6IG51bWJlclxuXG4gICAgICAgICAgICBzd2l0Y2ggKGNlbGwuZHJhd0RpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgIGNhc2UgQ2VsbERyYXdEaXJlY3Rpb24uRE9XTjpcbiAgICAgICAgICAgICAgICBjYXNlIENlbGxEcmF3RGlyZWN0aW9uLlVQOlxuICAgICAgICAgICAgICAgICAgICBsaW1pdFZhbHVlID0gY2VsbC5oZWlnaHQgLSBjZWxsLm9yaWdpbmFsRGltZW5zaW9ucy5oZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICBjYXNlIENlbGxEcmF3RGlyZWN0aW9uLlJJR0hUOlxuICAgICAgICAgICAgICAgIGNhc2UgQ2VsbERyYXdEaXJlY3Rpb24uTEVGVDpcbiAgICAgICAgICAgICAgICAgICAgbGltaXRWYWx1ZSA9IGNlbGwud2lkdGggLSBjZWxsLm9yaWdpbmFsRGltZW5zaW9ucy53aWR0aFxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGxpbWl0VmFsdWUgPSAwXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGluY3JlbWVudENlbGwgPSAoXG4gICAgICAgICAgICAgICAgaW5jcmVtZW50OiBudW1iZXJcbiAgICAgICAgICAgICk6IHtcbiAgICAgICAgICAgICAgICB0b3A6IG51bWJlclxuICAgICAgICAgICAgICAgIGxlZnQ6IG51bWJlclxuICAgICAgICAgICAgICAgIGhlaWdodDogbnVtYmVyXG4gICAgICAgICAgICAgICAgd2lkdGg6IG51bWJlclxuICAgICAgICAgICAgfSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGRyYXdEaXJlY3Rpb24gaXM6XG4gICAgICAgICAgICAgICAgLy8gUklHSFQ6IHdlIGluY3JlbWVudGFsbHkgaW5jcmVhc2UgdGhlIHdpZHRoXG4gICAgICAgICAgICAgICAgLy8gTEVGVDogd2UgaW5jcmVtZW50YWxseSBpbmNyZWFzZSB0aGUgd2lkdGggdmFsdWUgYW5kIGRlY3JlbWVudCB0aGUgbGVmdC5cbiAgICAgICAgICAgICAgICAvLyBVUDogd2UgaW5jcmVtZW50YWxseSBpbmNyZWFzZSB0aGUgaGVpZ2h0IGFuZCBkZWNyZW1lbnQgdGhlIHRvcCB2YWx1ZS5cbiAgICAgICAgICAgICAgICAvLyBET1dOOiB3ZSBpbmNyZW1lbnRhbGx5IGluY3JlYXNlIHRoZSBoZWlnaHRcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGNlbGwuZHJhd0RpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENlbGxEcmF3RGlyZWN0aW9uLkRPV046XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogY2VsbC50b3AsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogY2VsbC5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogaW5jcmVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBjZWxsLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIENlbGxEcmF3RGlyZWN0aW9uLlVQOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwudG9wICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC5oZWlnaHQgLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsLm9yaWdpbmFsRGltZW5zaW9ucy5oZWlnaHQgLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmNyZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogY2VsbC5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogY2VsbC5vcmlnaW5hbERpbWVuc2lvbnMuaGVpZ2h0ICsgaW5jcmVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBjZWxsLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIENlbGxEcmF3RGlyZWN0aW9uLkxFRlQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogY2VsbC50b3AsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC5sZWZ0ICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC53aWR0aCAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwub3JpZ2luYWxEaW1lbnNpb25zLndpZHRoIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5jcmVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogY2VsbC5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGNlbGwub3JpZ2luYWxEaW1lbnNpb25zLndpZHRoICsgaW5jcmVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIENlbGxEcmF3RGlyZWN0aW9uLlJJR0hUOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6IGNlbGwudG9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGNlbGwubGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGNlbGwuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBpbmNyZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGRyYXcgPSAodGltZVN0YW1wOiBudW1iZXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29udGV4dCB8fCAhdGhpcy5hbmltYXRpb25SdW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvbkZyYW1lSWQpXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFzdGFydFRpbWVzdGFtcCkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydFRpbWVzdGFtcCA9IHRpbWVTdGFtcFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBlbGFwc2VkID0gdGltZVN0YW1wIC0gc3RhcnRUaW1lc3RhbXBcbiAgICAgICAgICAgICAgICBjb25zdCByZWxhdGl2ZVByb2dyZXNzID0gZWxhcHNlZCAvIElOVEVSVkFMXG4gICAgICAgICAgICAgICAgY29uc3QgaW5jcmVtZW50ID0gbGltaXRWYWx1ZSAqIE1hdGgubWluKHJlbGF0aXZlUHJvZ3Jlc3MsIDEpXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3RGltZW5zaW9ucyA9IGluY3JlbWVudENlbGwoaW5jcmVtZW50KVxuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5maWxsUmVjdChcbiAgICAgICAgICAgICAgICAgICAgbmV3RGltZW5zaW9ucy5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICBuZXdEaW1lbnNpb25zLnRvcCxcbiAgICAgICAgICAgICAgICAgICAgbmV3RGltZW5zaW9ucy53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgbmV3RGltZW5zaW9ucy5oZWlnaHRcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgaWYgKGVsYXBzZWQgPj0gSU5URVJWQUwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0cnVlKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbkZyYW1lSWQgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGRyYXcpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhbmltYXRpb25GcmFtZUlkID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShkcmF3KVxuXG4gICAgICAgICAgICAvLyBDbGVhbnVwIGZ1bmN0aW9uIGZvciB0aGUgcHJvbWlzZVxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYW5pbWF0aW9uRnJhbWVJZCkge1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShhbmltYXRpb25GcmFtZUlkKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICBwcml2YXRlIGRyYXdMb2FkZXJDZWxsKHBhdXNlOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQgfHwgIXRoaXMuYW5pbWF0aW9uUnVubmluZykgcmV0dXJuXG5cbiAgICAgICAgdGhpcy5jb250ZXh0LmZpbGxTdHlsZSA9IHRoaXMuYmFja2dyb3VuZENvbG9yXG4gICAgICAgIGxldCBzdGFydFRpbWVzdGFtcDogbnVtYmVyXG5cbiAgICAgICAgY29uc3QgZHJhdyA9ICh0aW1lU3RhbXA6IG51bWJlcikgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQgfHwgIXRoaXMuYW5pbWF0aW9uUnVubmluZykgcmV0dXJuXG5cbiAgICAgICAgICAgIGlmICghc3RhcnRUaW1lc3RhbXApIHtcbiAgICAgICAgICAgICAgICBzdGFydFRpbWVzdGFtcCA9IHRpbWVTdGFtcFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZWxhcHNlZCA9IHRpbWVTdGFtcCAtIHN0YXJ0VGltZXN0YW1wXG4gICAgICAgICAgICBjb25zdCByZWxhdGl2ZVByb2dyZXNzID0gZWxhcHNlZCAvIHBhdXNlXG4gICAgICAgICAgICBjb25zdCBpbmNyZW1lbnQgPSB0aGlzLmdyaWRXaWR0aCAqIE1hdGgubWluKHJlbGF0aXZlUHJvZ3Jlc3MsIDEpXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuZmlsbFJlY3QoMCwgMCwgaW5jcmVtZW50LCA1KVxuICAgICAgICAgICAgaWYgKGVsYXBzZWQgPj0gcGF1c2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShkcmF3KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShkcmF3KVxuICAgIH1cblxuICAgIHByaXZhdGUgZGVnZW5lcmF0ZUNoaWxkcmVuKGNlbGxzOiBDZWxsW10pOiBDZWxsW10ge1xuICAgICAgICAvLyBmaXJzdCwgYm90aCBjb21iYXRhbnRzIG11c3QgaGF2ZSBubyBjaGlsZHJlbjpcbiAgICAgICAgaWYgKGNlbGxzWzBdLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNlbGxzWzBdLmNoaWxkcmVuID0gdGhpcy5kZWdlbmVyYXRlQ2hpbGRyZW4oY2VsbHNbMF0uY2hpbGRyZW4pXG4gICAgICAgICAgICByZXR1cm4gY2VsbHNcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2VsbHNbMV0/LmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNlbGxzWzFdLmNoaWxkcmVuID0gdGhpcy5kZWdlbmVyYXRlQ2hpbGRyZW4oY2VsbHNbMV0uY2hpbGRyZW4pXG4gICAgICAgICAgICByZXR1cm4gY2VsbHNcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2VsbHMubGVuZ3RoID09PSAxICYmIGNlbGxzWzBdLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZ3JpZFR5cGU6IEdyaWRUeXBlID1cbiAgICAgICAgICAgIGNlbGxzWzBdLnRvcCA9PT0gY2VsbHNbMV0udG9wID8gR3JpZFR5cGUuUk9XIDogR3JpZFR5cGUuQ09MVU1OXG4gICAgICAgIGNvbnN0IHdpbm5lciA9IE1hdGgucmFuZG9tKClcbiAgICAgICAgY29uc3QgbmV3Q2VsbHMgPSBjZWxsc1xuICAgICAgICAgICAgLmZpbHRlcigoX2NlbGwsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHdpbm5lciA8IDAuNSAmJiBpbmRleCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHdpbm5lciA+PSAwLjUgJiYgaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm1hcCgoY2VsbCk6IENlbGwgPT4ge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBjZWxsIGluZGV4IGlzIHRoZSBmaXJzdCwgaXQgaXMgdGhlIHdpbm5lclxuICAgICAgICAgICAgICAgIC8vIHdhcyBpdCB0aGUgZmlyc3Qgb3IgdGhlIHNlY29uZD9cbiAgICAgICAgICAgICAgICAvLyBpZiB3aW5uZXIgPCAwLjUgaXQgd2FzIHRoZSBmaXJzdFxuICAgICAgICAgICAgICAgIC8vIGlmIHdpbm5lciA+PSAwLjUgaXQgd2FzIHRoZSBzZWNvbmRcbiAgICAgICAgICAgICAgICBjb25zdCBkcmF3RGlyZWN0aW9uID1cbiAgICAgICAgICAgICAgICAgICAgd2lubmVyIDwgMC41XG4gICAgICAgICAgICAgICAgICAgICAgICA/IGNlbGwuZHJhd0RpcmVjdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgOiBncmlkVHlwZSA9PT0gR3JpZFR5cGUuQ09MVU1OXG4gICAgICAgICAgICAgICAgICAgICAgICA/IENlbGxEcmF3RGlyZWN0aW9uLlVQXG4gICAgICAgICAgICAgICAgICAgICAgICA6IENlbGxEcmF3RGlyZWN0aW9uLkxFRlRcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5jZWxsLFxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogY2VsbC5kZXB0aCA8IDIgPyB0aGlzLmJhY2tncm91bmRDb2xvciA6IGNlbGwuY29sb3IsXG4gICAgICAgICAgICAgICAgICAgIGRyYXdEaXJlY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRGltZW5zaW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBjZWxsLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBjZWxsLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIGlmIChncmlkVHlwZSA9PT0gR3JpZFR5cGUuQ09MVU1OKSB7XG4gICAgICAgICAgICBuZXdDZWxsc1swXS5oZWlnaHQgPSBjZWxsc1swXS5oZWlnaHQgKyBjZWxsc1sxXS5oZWlnaHRcbiAgICAgICAgICAgIGlmICh3aW5uZXIgPj0gMC41KSB7XG4gICAgICAgICAgICAgICAgbmV3Q2VsbHNbMF0udG9wID0gY2VsbHNbMF0udG9wXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyaWRUeXBlID09PSBHcmlkVHlwZS5ST1cpIHtcbiAgICAgICAgICAgIG5ld0NlbGxzWzBdLndpZHRoID0gY2VsbHNbMF0ud2lkdGggKyBjZWxsc1sxXS53aWR0aFxuICAgICAgICAgICAgaWYgKHdpbm5lciA+PSAwLjUpIHtcbiAgICAgICAgICAgICAgICBuZXdDZWxsc1swXS5sZWZ0ID0gY2VsbHNbMF0ubGVmdFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHB1c2ggdGhlIHdpbm5lclxuICAgICAgICB0aGlzLmZsYXRHcmlkLnB1c2gobmV3Q2VsbHNbMF0pXG4gICAgICAgIHJldHVybiBuZXdDZWxsc1xuICAgIH1cblxuICAgIHByaXZhdGUgZGVzdHJveUdyaWQoKTogdm9pZCB7XG4gICAgICAgIGlmICghdGhpcy5hbmltYXRpb25SdW5uaW5nKSByZXR1cm5cblxuICAgICAgICBjb25zdCBncmlkQ2VsbCA9IHRoaXMuZmxhdEdyaWRbMF1cbiAgICAgICAgdGhpcy5mbGF0R3JpZCA9IFtdXG4gICAgICAgIHdoaWxlIChncmlkQ2VsbD8uY2hpbGRyZW4/Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGdyaWRDZWxsLmNoaWxkcmVuID0gdGhpcy5kZWdlbmVyYXRlQ2hpbGRyZW4oZ3JpZENlbGwuY2hpbGRyZW4pXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hbmltYXRlR3JpZCgpXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmVhdGVHcmlkKCk6IHZvaWQge1xuICAgICAgICBpZiAoIXRoaXMuY29udGV4dCB8fCAhdGhpcy5hbmltYXRpb25SdW5uaW5nKSByZXR1cm5cblxuICAgICAgICB0aGlzLmNvbnRleHQuZmlsbFN0eWxlID0gdGhpcy5iYWNrZ3JvdW5kQ29sb3JcbiAgICAgICAgdGhpcy5jb250ZXh0LmZpbGxSZWN0KDAsIDAsIHRoaXMuZ3JpZFdpZHRoLCB0aGlzLmdyaWRIZWlnaHQpXG5cbiAgICAgICAgdGhpcy5ncmlkU2NhZmZvbGQgPSB0aGlzLmNyZWF0ZUdyaWRTY2FmZm9sZCgpXG4gICAgICAgIHRoaXMuZ3JpZCA9IHtcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5ncmlkSGVpZ2h0LFxuICAgICAgICAgICAgd2lkdGg6IHRoaXMuZ3JpZFdpZHRoLFxuICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgICAgICAgIGRlcHRoOiAwLFxuICAgICAgICAgICAgY29sb3I6IHRoaXMuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgZHJhd0RpcmVjdGlvbjogQ2VsbERyYXdEaXJlY3Rpb24uUklHSFQsXG4gICAgICAgICAgICBvcmlnaW5hbERpbWVuc2lvbnM6IHtcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMuZ3JpZEhlaWdodCxcbiAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy5ncmlkV2lkdGgsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmxhdEdyaWQgPSBbXVxuICAgICAgICB0aGlzLmdlbmVyYXRlR3JpZCh0aGlzLmdyaWQpXG4gICAgICAgIHRoaXMuYW5pbWF0ZUdyaWQoKVxuICAgIH1cblxuICAgIHByaXZhdGUgY2hlY2tHcmlkKCk6IHZvaWQge1xuICAgICAgICBjb25zdCB0b3RhbEdyaWRTaXplID0gdGhpcy5ncmlkV2lkdGggKiB0aGlzLmdyaWRIZWlnaHRcbiAgICAgICAgY29uc3QgdG90YWxDZWxsU2l6ZSA9IHRoaXMuZmxhdEdyaWRcbiAgICAgICAgICAgIC5maWx0ZXIoKGNlbGwpID0+IGNlbGwuY2hpbGRyZW4ubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgLm1hcCgoYykgPT4gYy5oZWlnaHQgKiBjLndpZHRoKVxuICAgICAgICAgICAgLnJlZHVjZSh0aGlzLnN1bSwgMClcbiAgICAgICAgY29uc29sZS53YXJuKHRvdGFsR3JpZFNpemUsIHRvdGFsQ2VsbFNpemUpXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBhbmltYXRlR3JpZCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgaWYgKCF0aGlzLmFuaW1hdGlvblJ1bm5pbmcpIHJldHVyblxuXG4gICAgICAgIGlmICh0aGlzLmZsYXRHcmlkW3RoaXMuaW5kZXhdKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuZHJhd0NlbGwodGhpcy5pbmRleClcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4KytcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pbmRleCA8IHRoaXMuZmxhdEdyaWQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmFuaW1hdGlvblJ1bm5pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgdG8gYXZvaWQgc3RhY2sgb3ZlcmZsb3cgd2l0aCBkZWVwIHJlY3Vyc2lvblxuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLmFuaW1hdGVHcmlkKCkpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4ID0gMFxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgbGFzdCBjZWxsIGluIHRoZSBmbGF0IGdyaWQgaXMgdGhlIHNhbWUgZGltZW5zaW9ucyBhcyB0aGUgZ3JpZFdpZHRoIGFuZCBncmlkSGVpZ2h0LCB0aGVuIHdlIGp1c3QgZmluaXNoZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gZGVzdHJveWluZyB0aGUgZ3JpZCwgYW5kIG5lZWQgdG8gc3RhcnQgYSBuZXcgZ3JpZFxuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLnJvdW5kKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmxhdEdyaWRbdGhpcy5mbGF0R3JpZC5sZW5ndGggLSAxXT8ud2lkdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICkgPT09IHRoaXMuZ3JpZFdpZHRoICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLnJvdW5kKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmxhdEdyaWRbdGhpcy5mbGF0R3JpZC5sZW5ndGggLSAxXT8uaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgICAgICApID09PSB0aGlzLmdyaWRIZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUdyaWQoKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZVBhbGV0dGUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aW1lb3V0SWQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYW5pbWF0aW9uUnVubmluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlc3Ryb3lHcmlkKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAzMDAwKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBhbiBlcnJvciBvY2N1cnMgKGxpa2Ugd2hlbiBjb21wb25lbnQgaXMgZGVzdHJveWVkKSwganVzdCBzdG9wIHRoZSBhbmltYXRpb25cbiAgICAgICAgICAgICAgICAvLyB3aXRob3V0IGxvZ2dpbmcgYW4gZXJyb3IsIGFzIHRoaXMgaXMgZXhwZWN0ZWQgYmVoYXZpb3Igd2hlbiBzdG9wcGluZ1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFuaW1hdGlvblJ1bm5pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYW5pbWF0aW5nIGdyaWQ6JywgZXJyb3IpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pbmRleCsrXG4gICAgICAgICAgICBpZiAodGhpcy5pbmRleCA8IHRoaXMuZmxhdEdyaWQubGVuZ3RoICYmIHRoaXMuYW5pbWF0aW9uUnVubmluZykge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy5hbmltYXRlR3JpZCgpKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgY29uc3QgYnVpbGRBbmRBbmltYXRlR3JpZCA9IChjYW52YXNJZDogc3RyaW5nKTogR3JpZEFuaW1hdG9yID0+IHtcbiAgICBjb25zdCBhbmltYXRvciA9IG5ldyBHcmlkQW5pbWF0b3IoY2FudmFzSWQpXG4gICAgYW5pbWF0b3Iuc3RhcnQoKVxuICAgIHJldHVybiBhbmltYXRvclxufVxuIl0sIm5hbWVzIjpbIkdyaWRUeXBlIiwiQ2VsbERyYXdEaXJlY3Rpb24iLCJTV0VFVE5FU1MiLCJJTlRFUlZBTCIsIkhVRV9SQU5HRSIsIlNBVFVSQVRJT05fUkFOR0UiLCJMSUdIVE5FU1NfUkFOR0UiLCJHcmlkQW5pbWF0b3IiLCJzdGFydCIsImNhbnZhcyIsImNvbnRleHQiLCJjb25zb2xlIiwiZXJyb3IiLCJhbmltYXRpb25SdW5uaW5nIiwiY3JlYXRlR3JpZCIsInN0b3AiLCJ0aW1lb3V0SWQiLCJ3aW5kb3ciLCJjbGVhclRpbWVvdXQiLCJmbGF0R3JpZCIsImdyaWQiLCJkZXN0cm95IiwiY2xlYXJSZWN0Iiwid2lkdGgiLCJoZWlnaHQiLCJnZW5lcmF0ZUNsYW1wIiwiZG9tYWluIiwicmFuZ2UiLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJnZW5lcmF0ZUNpcmN1bGFyQ2xhbXAiLCJlbmQiLCJnZXRSYW5kb21IdWUiLCJtaW4iLCJodWVDbGFtcCIsIm1heCIsInZhbHVlIiwiZ2V0UmFuZG9tQ2xhbXBlZCIsImNlaWwiLCJyYW5kb21Db2xvciIsInNhdHVyYXRpb25DbGFtcCIsImxpZ2h0bmVzc0NsYW1wIiwiZ2VuZXJhdGVQYWxldHRlIiwiYmFja2dyb3VuZENvbG9yIiwic3VtIiwicGFydGlhbFN1bSIsImEiLCJnZXRWYWx1ZSIsInN3ZWV0IiwiY291bnQiLCJjb2VmZmljaWVudCIsInByb2dyZXNzIiwiY3JlYXRlU3ByZWFkIiwic3ByZWFkIiwicmVtYWluaW5nIiwicmFuZG9tUG9pbnRzIiwiaSIsInB1c2giLCJzb3J0IiwiYiIsInByZXZpb3VzUG9pbnQiLCJwb2ludCIsImNodW5rU2l6ZSIsInNldHVwQ2FudmFzIiwiY2FudmFzSWQiLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwiZ2V0Q29udGV4dCIsImRwciIsImRldmljZVBpeGVsUmF0aW8iLCJyZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwic2NhbGUiLCJncmlkSGVpZ2h0IiwiZ3JpZFdpZHRoIiwiY3JlYXRlR3JpZFNjYWZmb2xkIiwiY29sdW1uTGVuZ3RoIiwicm93TGVuZ3RoIiwiZ3JpZFNjYWZmb2xkIiwiY29sdW1ucyIsInJvd3MiLCJjaG9vc2VHcmlkVHlwZSIsImdlbmVyYXRlUm93IiwicGFyZW50Q2VsbCIsIm1hcCIsImNvbHVtbiIsImluZGV4IiwidG9wIiwibGVmdCIsInNsaWNlIiwicmVkdWNlIiwiZGVwdGgiLCJjb2xvciIsImNoaWxkcmVuIiwiZHJhd0RpcmVjdGlvbiIsIm9yaWdpbmFsRGltZW5zaW9ucyIsImdlbmVyYXRlQ29sdW1uIiwicm93IiwiZ2V0TGV2ZWwyQ29sdW1ucyIsImJyZWFrb3V0Q2hhbmNlIiwic2tpcENlbGxzIiwibmV3Q29sdW1ucyIsImZvckVhY2giLCJjb2x1bW5JbmRleCIsImluY2x1ZGVzIiwibGVuZ3RoIiwibnVtYmVyT2ZSZW1haW5pbmdDb2x1bW5zIiwiY29sdW1uU3BhbiIsIm5ld0NvbHVtbiIsImMiLCJnZW5lcmF0ZUNoaWxkcmVuIiwiZ3JpZFR5cGUiLCJnZW5lcmF0ZUdyaWQiLCJjZWxsIiwiY2hpbGQiLCJkcmF3Q2VsbCIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiZmlsbFN0eWxlIiwic3RhcnRUaW1lc3RhbXAiLCJsaW1pdFZhbHVlIiwiYW5pbWF0aW9uRnJhbWVJZCIsImluY3JlbWVudENlbGwiLCJpbmNyZW1lbnQiLCJkcmF3IiwidGltZVN0YW1wIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJlbGFwc2VkIiwicmVsYXRpdmVQcm9ncmVzcyIsIm5ld0RpbWVuc2lvbnMiLCJmaWxsUmVjdCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImRyYXdMb2FkZXJDZWxsIiwicGF1c2UiLCJkZWdlbmVyYXRlQ2hpbGRyZW4iLCJjZWxscyIsIndpbm5lciIsIm5ld0NlbGxzIiwiZmlsdGVyIiwiX2NlbGwiLCJkZXN0cm95R3JpZCIsImdyaWRDZWxsIiwiYW5pbWF0ZUdyaWQiLCJjaGVja0dyaWQiLCJ0b3RhbEdyaWRTaXplIiwidG90YWxDZWxsU2l6ZSIsIndhcm4iLCJyb3VuZCIsInNldFRpbWVvdXQiLCJjb25zdHJ1Y3RvciIsImJ1aWxkQW5kQW5pbWF0ZUdyaWQiLCJhbmltYXRvciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./animations/script.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/page.tsx":
/*!**********************!*\
  !*** ./app/page.tsx ***!
  \**********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ GridCanvas)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _animations_script__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/animations/script */ \"(app-pages-browser)/./animations/script.ts\");\n/* harmony import */ var _components_AboutPanel__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/components/AboutPanel */ \"(app-pages-browser)/./components/AboutPanel.tsx\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\nfunction GridCanvas() {\n    _s();\n    const [aboutHidden, setAboutHidden] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const toggleAboutPanel = ()=>{\n        setAboutHidden(!aboutHidden);\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"GridCanvas.useEffect\": ()=>{\n            const animator = (0,_animations_script__WEBPACK_IMPORTED_MODULE_2__.buildAndAnimateGrid)('grid-canvas');\n            return ({\n                \"GridCanvas.useEffect\": ()=>{\n                    animator.destroy();\n                }\n            })[\"GridCanvas.useEffect\"];\n        }\n    }[\"GridCanvas.useEffect\"], []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"overflow-hidden absolute top-[60px] left-0 w-full h-[calc(100%-60px)] lg:h-full lg:top-0\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                onClick: toggleAboutPanel,\n                className: \"transition absolute top-4 right-4 w-[35px] h-[35px] rounded-full bg-[#22222244] hover:bg-[#22222299] z-5 flex items-center justify-center text-white text-xl cursor-pointer\",\n                children: aboutHidden ? '?' : 'X'\n            }, void 0, false, {\n                fileName: \"/Users/jefffohl/dev/website/frontend/app/page.tsx\",\n                lineNumber: 23,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_AboutPanel__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                isHidden: aboutHidden,\n                onClose: toggleAboutPanel\n            }, void 0, false, {\n                fileName: \"/Users/jefffohl/dev/website/frontend/app/page.tsx\",\n                lineNumber: 29,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n                id: \"grid-canvas\",\n                className: \"w-full h-full block\"\n            }, void 0, false, {\n                fileName: \"/Users/jefffohl/dev/website/frontend/app/page.tsx\",\n                lineNumber: 30,\n                columnNumber: 13\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/jefffohl/dev/website/frontend/app/page.tsx\",\n        lineNumber: 22,\n        columnNumber: 9\n    }, this);\n}\n_s(GridCanvas, \"e7Th+1UW0J49Eu1Fhr0in3GeQ4c=\");\n_c = GridCanvas;\nvar _c;\n$RefreshReg$(_c, \"GridCanvas\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9wYWdlLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUUyQztBQUNjO0FBQ1Q7QUFFakMsU0FBU0k7O0lBQ3BCLE1BQU0sQ0FBQ0MsYUFBYUMsZUFBZSxHQUFHTCwrQ0FBUUEsQ0FBQztJQUUvQyxNQUFNTSxtQkFBbUI7UUFDckJELGVBQWUsQ0FBQ0Q7SUFDcEI7SUFFQUwsZ0RBQVNBO2dDQUFDO1lBQ04sTUFBTVEsV0FBV04sdUVBQW1CQSxDQUFDO1lBQ3JDO3dDQUFPO29CQUNITSxTQUFTQyxPQUFPO2dCQUNwQjs7UUFDSjsrQkFBRyxFQUFFO0lBRUwscUJBQ0ksOERBQUNDO1FBQUlDLFdBQVU7OzBCQUNYLDhEQUFDRDtnQkFDR0UsU0FBU0w7Z0JBQ1RJLFdBQVU7MEJBRVROLGNBQWMsTUFBTTs7Ozs7OzBCQUV6Qiw4REFBQ0YsOERBQVVBO2dCQUFDVSxVQUFVUjtnQkFBYVMsU0FBU1A7Ozs7OzswQkFDNUMsOERBQUNRO2dCQUFPQyxJQUFHO2dCQUFjTCxXQUFVOzs7Ozs7Ozs7Ozs7QUFHL0M7R0ExQndCUDtLQUFBQSIsInNvdXJjZXMiOlsiL1VzZXJzL2plZmZmb2hsL2Rldi93ZWJzaXRlL2Zyb250ZW5kL2FwcC9wYWdlLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgYnVpbGRBbmRBbmltYXRlR3JpZCB9IGZyb20gJ0AvYW5pbWF0aW9ucy9zY3JpcHQnXG5pbXBvcnQgQWJvdXRQYW5lbCBmcm9tICdAL2NvbXBvbmVudHMvQWJvdXRQYW5lbCdcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gR3JpZENhbnZhcygpIHtcbiAgICBjb25zdCBbYWJvdXRIaWRkZW4sIHNldEFib3V0SGlkZGVuXSA9IHVzZVN0YXRlKHRydWUpXG5cbiAgICBjb25zdCB0b2dnbGVBYm91dFBhbmVsID0gKCkgPT4ge1xuICAgICAgICBzZXRBYm91dEhpZGRlbighYWJvdXRIaWRkZW4pXG4gICAgfVxuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgYW5pbWF0b3IgPSBidWlsZEFuZEFuaW1hdGVHcmlkKCdncmlkLWNhbnZhcycpXG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBhbmltYXRvci5kZXN0cm95KClcbiAgICAgICAgfVxuICAgIH0sIFtdKVxuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJvdmVyZmxvdy1oaWRkZW4gYWJzb2x1dGUgdG9wLVs2MHB4XSBsZWZ0LTAgdy1mdWxsIGgtW2NhbGMoMTAwJS02MHB4KV0gbGc6aC1mdWxsIGxnOnRvcC0wXCI+XG4gICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgb25DbGljaz17dG9nZ2xlQWJvdXRQYW5lbH1cbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ0cmFuc2l0aW9uIGFic29sdXRlIHRvcC00IHJpZ2h0LTQgdy1bMzVweF0gaC1bMzVweF0gcm91bmRlZC1mdWxsIGJnLVsjMjIyMjIyNDRdIGhvdmVyOmJnLVsjMjIyMjIyOTldIHotNSBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciB0ZXh0LXdoaXRlIHRleHQteGwgY3Vyc29yLXBvaW50ZXJcIlxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIHthYm91dEhpZGRlbiA/ICc/JyA6ICdYJ31cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPEFib3V0UGFuZWwgaXNIaWRkZW49e2Fib3V0SGlkZGVufSBvbkNsb3NlPXt0b2dnbGVBYm91dFBhbmVsfSAvPlxuICAgICAgICAgICAgPGNhbnZhcyBpZD1cImdyaWQtY2FudmFzXCIgY2xhc3NOYW1lPVwidy1mdWxsIGgtZnVsbCBibG9ja1wiIC8+XG4gICAgICAgIDwvZGl2PlxuICAgIClcbn1cbiJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VTdGF0ZSIsImJ1aWxkQW5kQW5pbWF0ZUdyaWQiLCJBYm91dFBhbmVsIiwiR3JpZENhbnZhcyIsImFib3V0SGlkZGVuIiwic2V0QWJvdXRIaWRkZW4iLCJ0b2dnbGVBYm91dFBhbmVsIiwiYW5pbWF0b3IiLCJkZXN0cm95IiwiZGl2IiwiY2xhc3NOYW1lIiwib25DbGljayIsImlzSGlkZGVuIiwib25DbG9zZSIsImNhbnZhcyIsImlkIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/page.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/AboutPanel.tsx":
/*!***********************************!*\
  !*** ./components/AboutPanel.tsx ***!
  \***********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ AboutPanel)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _SubPanel_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SubPanel.css */ \"(app-pages-browser)/./components/SubPanel.css\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \n\nfunction AboutPanel(param) {\n    let { isHidden } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"z-4 sub-panel right \".concat(isHidden ? 'outta-sight' : ''),\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                children: \"What is this all about? \"\n            }, void 0, false, {\n                fileName: \"/Users/jefffohl/dev/website/frontend/components/AboutPanel.tsx\",\n                lineNumber: 13,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"panel-content\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        children: [\n                            \"What you see happening on this page started out as a doodle, initially inspired by abstract works by artists such as\",\n                            ' ',\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                href: \"https://diebenkorn.org/collections/6673/objects/\",\n                                target: \"_blank\",\n                                children: \"Richard Diebenkorn\"\n                            }, void 0, false, {\n                                fileName: \"/Users/jefffohl/dev/website/frontend/components/AboutPanel.tsx\",\n                                lineNumber: 18,\n                                columnNumber: 21\n                            }, this),\n                            \". The doodle evolved over time into a kind of grid, dancing in my mind between the abstract and the concrete.\"\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/jefffohl/dev/website/frontend/components/AboutPanel.tsx\",\n                        lineNumber: 15,\n                        columnNumber: 17\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        children: [\n                            \"I became curious if I could write an algorithm to generate variants on the design. Something perhaps similar to\",\n                            ' ',\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                href: \"https://mathworld.wolfram.com/Rule110.html\",\n                                target: \"_blank\",\n                                children: \"cellular automata\"\n                            }, void 0, false, {\n                                fileName: \"/Users/jefffohl/dev/website/frontend/components/AboutPanel.tsx\",\n                                lineNumber: 30,\n                                columnNumber: 21\n                            }, this),\n                            \", but turned on its head. Instead of writing an algorithm to see what it would produce, I started with an idea of what I wanted the end product to look like, and crafted my algorithm to produce something akin to that. That idea evolved in to what you see creating and destroying itself here. With some relatively simple rules for generating the design, and then deconstructing it, the system will endlessly explore these ideas of abstraction.\",\n                            ' ',\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                href: \"https://github.com/jefffohl/website\",\n                                target: \"_blank\",\n                                children: \"You can see the code here.\"\n                            }, void 0, false, {\n                                fileName: \"/Users/jefffohl/dev/website/frontend/components/AboutPanel.tsx\",\n                                lineNumber: 44,\n                                columnNumber: 21\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/jefffohl/dev/website/frontend/components/AboutPanel.tsx\",\n                        lineNumber: 27,\n                        columnNumber: 17\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        children: \"What I find fascinating here is how our minds will look at this random arrangement of rectangles and inevitably attempt to identify it, to classify it. Is it a landscape? An aerial view of farmland? A slice of metamorphic schist? What I find interesting is that what our minds do here seems to be similar to the behavior of neural nets. Does this mean that these algorithms are getting closer to the way our own minds process information and perceive the world? I don't really know. But it is an interesting question.\"\n                    }, void 0, false, {\n                        fileName: \"/Users/jefffohl/dev/website/frontend/components/AboutPanel.tsx\",\n                        lineNumber: 51,\n                        columnNumber: 17\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/jefffohl/dev/website/frontend/components/AboutPanel.tsx\",\n                lineNumber: 14,\n                columnNumber: 13\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/jefffohl/dev/website/frontend/components/AboutPanel.tsx\",\n        lineNumber: 12,\n        columnNumber: 9\n    }, this);\n}\n_c = AboutPanel;\nvar _c;\n$RefreshReg$(_c, \"AboutPanel\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvQWJvdXRQYW5lbC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUV1QjtBQU9SLFNBQVNBLFdBQVcsS0FBNkI7UUFBN0IsRUFBRUMsUUFBUSxFQUFtQixHQUE3QjtJQUMvQixxQkFDSSw4REFBQ0M7UUFBSUMsV0FBVyx1QkFBcUQsT0FBOUJGLFdBQVcsZ0JBQWdCOzswQkFDOUQsOERBQUNHOzBCQUFHOzs7Ozs7MEJBQ0osOERBQUNGO2dCQUFJQyxXQUFVOztrQ0FDWCw4REFBQ0U7OzRCQUFFOzRCQUV5RDswQ0FDeEQsOERBQUNDO2dDQUNHQyxNQUFLO2dDQUNMQyxRQUFPOzBDQUNWOzs7Ozs7NEJBRUc7Ozs7Ozs7a0NBSVIsOERBQUNIOzs0QkFBRTs0QkFFc0Q7MENBQ3JELDhEQUFDQztnQ0FDR0MsTUFBSztnQ0FDTEMsUUFBTzswQ0FDVjs7Ozs7OzRCQUVHOzRCQVEwQzswQ0FDOUMsOERBQUNGO2dDQUNHQyxNQUFLO2dDQUNMQyxRQUFPOzBDQUNWOzs7Ozs7Ozs7Ozs7a0NBSUwsOERBQUNIO2tDQUFFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFjbkI7S0F2RHdCTCIsInNvdXJjZXMiOlsiL1VzZXJzL2plZmZmb2hsL2Rldi93ZWJzaXRlL2Zyb250ZW5kL2NvbXBvbmVudHMvQWJvdXRQYW5lbC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbmltcG9ydCAnLi9TdWJQYW5lbC5jc3MnXG5cbmludGVyZmFjZSBBYm91dFBhbmVsUHJvcHMge1xuICAgIGlzSGlkZGVuOiBib29sZWFuXG4gICAgb25DbG9zZT86ICgpID0+IHZvaWRcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQWJvdXRQYW5lbCh7IGlzSGlkZGVuIH06IEFib3V0UGFuZWxQcm9wcykge1xuICAgIHJldHVybiAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtgei00IHN1Yi1wYW5lbCByaWdodCAke2lzSGlkZGVuID8gJ291dHRhLXNpZ2h0JyA6ICcnfWB9PlxuICAgICAgICAgICAgPGgyPldoYXQgaXMgdGhpcyBhbGwgYWJvdXQ/IDwvaDI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInBhbmVsLWNvbnRlbnRcIj5cbiAgICAgICAgICAgICAgICA8cD5cbiAgICAgICAgICAgICAgICAgICAgV2hhdCB5b3Ugc2VlIGhhcHBlbmluZyBvbiB0aGlzIHBhZ2Ugc3RhcnRlZCBvdXQgYXMgYSBkb29kbGUsXG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxseSBpbnNwaXJlZCBieSBhYnN0cmFjdCB3b3JrcyBieSBhcnRpc3RzIHN1Y2ggYXN7JyAnfVxuICAgICAgICAgICAgICAgICAgICA8YVxuICAgICAgICAgICAgICAgICAgICAgICAgaHJlZj1cImh0dHBzOi8vZGllYmVua29ybi5vcmcvY29sbGVjdGlvbnMvNjY3My9vYmplY3RzL1wiXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ9XCJfYmxhbmtcIlxuICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICBSaWNoYXJkIERpZWJlbmtvcm5cbiAgICAgICAgICAgICAgICAgICAgPC9hPlxuICAgICAgICAgICAgICAgICAgICAuIFRoZSBkb29kbGUgZXZvbHZlZCBvdmVyIHRpbWUgaW50byBhIGtpbmQgb2YgZ3JpZCwgZGFuY2luZ1xuICAgICAgICAgICAgICAgICAgICBpbiBteSBtaW5kIGJldHdlZW4gdGhlIGFic3RyYWN0IGFuZCB0aGUgY29uY3JldGUuXG4gICAgICAgICAgICAgICAgPC9wPlxuICAgICAgICAgICAgICAgIDxwPlxuICAgICAgICAgICAgICAgICAgICBJIGJlY2FtZSBjdXJpb3VzIGlmIEkgY291bGQgd3JpdGUgYW4gYWxnb3JpdGhtIHRvIGdlbmVyYXRlXG4gICAgICAgICAgICAgICAgICAgIHZhcmlhbnRzIG9uIHRoZSBkZXNpZ24uIFNvbWV0aGluZyBwZXJoYXBzIHNpbWlsYXIgdG97JyAnfVxuICAgICAgICAgICAgICAgICAgICA8YVxuICAgICAgICAgICAgICAgICAgICAgICAgaHJlZj1cImh0dHBzOi8vbWF0aHdvcmxkLndvbGZyYW0uY29tL1J1bGUxMTAuaHRtbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ9XCJfYmxhbmtcIlxuICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsdWxhciBhdXRvbWF0YVxuICAgICAgICAgICAgICAgICAgICA8L2E+XG4gICAgICAgICAgICAgICAgICAgICwgYnV0IHR1cm5lZCBvbiBpdHMgaGVhZC4gSW5zdGVhZCBvZiB3cml0aW5nIGFuIGFsZ29yaXRobSB0b1xuICAgICAgICAgICAgICAgICAgICBzZWUgd2hhdCBpdCB3b3VsZCBwcm9kdWNlLCBJIHN0YXJ0ZWQgd2l0aCBhbiBpZGVhIG9mIHdoYXQgSVxuICAgICAgICAgICAgICAgICAgICB3YW50ZWQgdGhlIGVuZCBwcm9kdWN0IHRvIGxvb2sgbGlrZSwgYW5kIGNyYWZ0ZWQgbXlcbiAgICAgICAgICAgICAgICAgICAgYWxnb3JpdGhtIHRvIHByb2R1Y2Ugc29tZXRoaW5nIGFraW4gdG8gdGhhdC4gVGhhdCBpZGVhXG4gICAgICAgICAgICAgICAgICAgIGV2b2x2ZWQgaW4gdG8gd2hhdCB5b3Ugc2VlIGNyZWF0aW5nIGFuZCBkZXN0cm95aW5nIGl0c2VsZlxuICAgICAgICAgICAgICAgICAgICBoZXJlLiBXaXRoIHNvbWUgcmVsYXRpdmVseSBzaW1wbGUgcnVsZXMgZm9yIGdlbmVyYXRpbmcgdGhlXG4gICAgICAgICAgICAgICAgICAgIGRlc2lnbiwgYW5kIHRoZW4gZGVjb25zdHJ1Y3RpbmcgaXQsIHRoZSBzeXN0ZW0gd2lsbFxuICAgICAgICAgICAgICAgICAgICBlbmRsZXNzbHkgZXhwbG9yZSB0aGVzZSBpZGVhcyBvZiBhYnN0cmFjdGlvbi57JyAnfVxuICAgICAgICAgICAgICAgICAgICA8YVxuICAgICAgICAgICAgICAgICAgICAgICAgaHJlZj1cImh0dHBzOi8vZ2l0aHViLmNvbS9qZWZmZm9obC93ZWJzaXRlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldD1cIl9ibGFua1wiXG4gICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgIFlvdSBjYW4gc2VlIHRoZSBjb2RlIGhlcmUuXG4gICAgICAgICAgICAgICAgICAgIDwvYT5cbiAgICAgICAgICAgICAgICA8L3A+XG4gICAgICAgICAgICAgICAgPHA+XG4gICAgICAgICAgICAgICAgICAgIFdoYXQgSSBmaW5kIGZhc2NpbmF0aW5nIGhlcmUgaXMgaG93IG91ciBtaW5kcyB3aWxsIGxvb2sgYXRcbiAgICAgICAgICAgICAgICAgICAgdGhpcyByYW5kb20gYXJyYW5nZW1lbnQgb2YgcmVjdGFuZ2xlcyBhbmQgaW5ldml0YWJseSBhdHRlbXB0XG4gICAgICAgICAgICAgICAgICAgIHRvIGlkZW50aWZ5IGl0LCB0byBjbGFzc2lmeSBpdC4gSXMgaXQgYSBsYW5kc2NhcGU/IEFuIGFlcmlhbFxuICAgICAgICAgICAgICAgICAgICB2aWV3IG9mIGZhcm1sYW5kPyBBIHNsaWNlIG9mIG1ldGFtb3JwaGljIHNjaGlzdD8gV2hhdCBJIGZpbmRcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJlc3RpbmcgaXMgdGhhdCB3aGF0IG91ciBtaW5kcyBkbyBoZXJlIHNlZW1zIHRvIGJlXG4gICAgICAgICAgICAgICAgICAgIHNpbWlsYXIgdG8gdGhlIGJlaGF2aW9yIG9mIG5ldXJhbCBuZXRzLiBEb2VzIHRoaXMgbWVhbiB0aGF0XG4gICAgICAgICAgICAgICAgICAgIHRoZXNlIGFsZ29yaXRobXMgYXJlIGdldHRpbmcgY2xvc2VyIHRvIHRoZSB3YXkgb3VyIG93biBtaW5kc1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzIGluZm9ybWF0aW9uIGFuZCBwZXJjZWl2ZSB0aGUgd29ybGQ/IEkgZG9uJmFwb3M7dFxuICAgICAgICAgICAgICAgICAgICByZWFsbHkga25vdy4gQnV0IGl0IGlzIGFuIGludGVyZXN0aW5nIHF1ZXN0aW9uLlxuICAgICAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICApXG59XG4iXSwibmFtZXMiOlsiQWJvdXRQYW5lbCIsImlzSGlkZGVuIiwiZGl2IiwiY2xhc3NOYW1lIiwiaDIiLCJwIiwiYSIsImhyZWYiLCJ0YXJnZXQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/AboutPanel.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/SubPanel.css":
/*!*********************************!*\
  !*** ./components/SubPanel.css ***!
  \*********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"6cc40dcd0565\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvU3ViUGFuZWwuY3NzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxjQUFjO0FBQzdCLElBQUksSUFBVSxJQUFJLGlCQUFpQiIsInNvdXJjZXMiOlsiL1VzZXJzL2plZmZmb2hsL2Rldi93ZWJzaXRlL2Zyb250ZW5kL2NvbXBvbmVudHMvU3ViUGFuZWwuY3NzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiNmNjNDBkY2QwNTY1XCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/SubPanel.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fjefffohl%2Fdev%2Fwebsite%2Ffrontend%2Fapp%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!":
/*!********************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fjefffohl%2Fdev%2Fwebsite%2Ffrontend%2Fapp%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false! ***!
  \********************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./app/page.tsx */ \"(app-pages-browser)/./app/page.tsx\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyJTJGVXNlcnMlMkZqZWZmZm9obCUyRmRldiUyRndlYnNpdGUlMkZmcm9udGVuZCUyRmFwcCUyRnBhZ2UudHN4JTIyJTJDJTIyaWRzJTIyJTNBJTVCJTVEJTdEJnNlcnZlcj1mYWxzZSEiLCJtYXBwaW5ncyI6IkFBQUEsc0pBQXNGIiwic291cmNlcyI6WyIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCIvVXNlcnMvamVmZmZvaGwvZGV2L3dlYnNpdGUvZnJvbnRlbmQvYXBwL3BhZ2UudHN4XCIpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fjefffohl%2Fdev%2Fwebsite%2Ffrontend%2Fapp%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  (function () {\n    function getComponentNameFromType(type) {\n      if (null == type) return null;\n      if (\"function\" === typeof type)\n        return type.$$typeof === REACT_CLIENT_REFERENCE\n          ? null\n          : type.displayName || type.name || null;\n      if (\"string\" === typeof type) return type;\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return \"Fragment\";\n        case REACT_PORTAL_TYPE:\n          return \"Portal\";\n        case REACT_PROFILER_TYPE:\n          return \"Profiler\";\n        case REACT_STRICT_MODE_TYPE:\n          return \"StrictMode\";\n        case REACT_SUSPENSE_TYPE:\n          return \"Suspense\";\n        case REACT_SUSPENSE_LIST_TYPE:\n          return \"SuspenseList\";\n      }\n      if (\"object\" === typeof type)\n        switch (\n          (\"number\" === typeof type.tag &&\n            console.error(\n              \"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"\n            ),\n          type.$$typeof)\n        ) {\n          case REACT_CONTEXT_TYPE:\n            return (type.displayName || \"Context\") + \".Provider\";\n          case REACT_CONSUMER_TYPE:\n            return (type._context.displayName || \"Context\") + \".Consumer\";\n          case REACT_FORWARD_REF_TYPE:\n            var innerType = type.render;\n            type = type.displayName;\n            type ||\n              ((type = innerType.displayName || innerType.name || \"\"),\n              (type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\"));\n            return type;\n          case REACT_MEMO_TYPE:\n            return (\n              (innerType = type.displayName || null),\n              null !== innerType\n                ? innerType\n                : getComponentNameFromType(type.type) || \"Memo\"\n            );\n          case REACT_LAZY_TYPE:\n            innerType = type._payload;\n            type = type._init;\n            try {\n              return getComponentNameFromType(type(innerType));\n            } catch (x) {}\n        }\n      return null;\n    }\n    function testStringCoercion(value) {\n      return \"\" + value;\n    }\n    function checkKeyStringCoercion(value) {\n      try {\n        testStringCoercion(value);\n        var JSCompiler_inline_result = !1;\n      } catch (e) {\n        JSCompiler_inline_result = !0;\n      }\n      if (JSCompiler_inline_result) {\n        JSCompiler_inline_result = console;\n        var JSCompiler_temp_const = JSCompiler_inline_result.error;\n        var JSCompiler_inline_result$jscomp$0 =\n          (\"function\" === typeof Symbol &&\n            Symbol.toStringTag &&\n            value[Symbol.toStringTag]) ||\n          value.constructor.name ||\n          \"Object\";\n        JSCompiler_temp_const.call(\n          JSCompiler_inline_result,\n          \"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.\",\n          JSCompiler_inline_result$jscomp$0\n        );\n        return testStringCoercion(value);\n      }\n    }\n    function getTaskName(type) {\n      if (type === REACT_FRAGMENT_TYPE) return \"<>\";\n      if (\n        \"object\" === typeof type &&\n        null !== type &&\n        type.$$typeof === REACT_LAZY_TYPE\n      )\n        return \"<...>\";\n      try {\n        var name = getComponentNameFromType(type);\n        return name ? \"<\" + name + \">\" : \"<...>\";\n      } catch (x) {\n        return \"<...>\";\n      }\n    }\n    function getOwner() {\n      var dispatcher = ReactSharedInternals.A;\n      return null === dispatcher ? null : dispatcher.getOwner();\n    }\n    function hasValidKey(config) {\n      if (hasOwnProperty.call(config, \"key\")) {\n        var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n        if (getter && getter.isReactWarning) return !1;\n      }\n      return void 0 !== config.key;\n    }\n    function defineKeyPropWarningGetter(props, displayName) {\n      function warnAboutAccessingKey() {\n        specialPropKeyWarningShown ||\n          ((specialPropKeyWarningShown = !0),\n          console.error(\n            \"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)\",\n            displayName\n          ));\n      }\n      warnAboutAccessingKey.isReactWarning = !0;\n      Object.defineProperty(props, \"key\", {\n        get: warnAboutAccessingKey,\n        configurable: !0\n      });\n    }\n    function elementRefGetterWithDeprecationWarning() {\n      var componentName = getComponentNameFromType(this.type);\n      didWarnAboutElementRef[componentName] ||\n        ((didWarnAboutElementRef[componentName] = !0),\n        console.error(\n          \"Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release.\"\n        ));\n      componentName = this.props.ref;\n      return void 0 !== componentName ? componentName : null;\n    }\n    function ReactElement(\n      type,\n      key,\n      self,\n      source,\n      owner,\n      props,\n      debugStack,\n      debugTask\n    ) {\n      self = props.ref;\n      type = {\n        $$typeof: REACT_ELEMENT_TYPE,\n        type: type,\n        key: key,\n        props: props,\n        _owner: owner\n      };\n      null !== (void 0 !== self ? self : null)\n        ? Object.defineProperty(type, \"ref\", {\n            enumerable: !1,\n            get: elementRefGetterWithDeprecationWarning\n          })\n        : Object.defineProperty(type, \"ref\", { enumerable: !1, value: null });\n      type._store = {};\n      Object.defineProperty(type._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: 0\n      });\n      Object.defineProperty(type, \"_debugInfo\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: null\n      });\n      Object.defineProperty(type, \"_debugStack\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugStack\n      });\n      Object.defineProperty(type, \"_debugTask\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugTask\n      });\n      Object.freeze && (Object.freeze(type.props), Object.freeze(type));\n      return type;\n    }\n    function jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self,\n      debugStack,\n      debugTask\n    ) {\n      var children = config.children;\n      if (void 0 !== children)\n        if (isStaticChildren)\n          if (isArrayImpl(children)) {\n            for (\n              isStaticChildren = 0;\n              isStaticChildren < children.length;\n              isStaticChildren++\n            )\n              validateChildKeys(children[isStaticChildren]);\n            Object.freeze && Object.freeze(children);\n          } else\n            console.error(\n              \"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\"\n            );\n        else validateChildKeys(children);\n      if (hasOwnProperty.call(config, \"key\")) {\n        children = getComponentNameFromType(type);\n        var keys = Object.keys(config).filter(function (k) {\n          return \"key\" !== k;\n        });\n        isStaticChildren =\n          0 < keys.length\n            ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\"\n            : \"{key: someKey}\";\n        didWarnAboutKeySpread[children + isStaticChildren] ||\n          ((keys =\n            0 < keys.length ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\"),\n          console.error(\n            'A props object containing a \"key\" prop is being spread into JSX:\\n  let props = %s;\\n  <%s {...props} />\\nReact keys must be passed directly to JSX without using spread:\\n  let props = %s;\\n  <%s key={someKey} {...props} />',\n            isStaticChildren,\n            children,\n            keys,\n            children\n          ),\n          (didWarnAboutKeySpread[children + isStaticChildren] = !0));\n      }\n      children = null;\n      void 0 !== maybeKey &&\n        (checkKeyStringCoercion(maybeKey), (children = \"\" + maybeKey));\n      hasValidKey(config) &&\n        (checkKeyStringCoercion(config.key), (children = \"\" + config.key));\n      if (\"key\" in config) {\n        maybeKey = {};\n        for (var propName in config)\n          \"key\" !== propName && (maybeKey[propName] = config[propName]);\n      } else maybeKey = config;\n      children &&\n        defineKeyPropWarningGetter(\n          maybeKey,\n          \"function\" === typeof type\n            ? type.displayName || type.name || \"Unknown\"\n            : type\n        );\n      return ReactElement(\n        type,\n        children,\n        self,\n        source,\n        getOwner(),\n        maybeKey,\n        debugStack,\n        debugTask\n      );\n    }\n    function validateChildKeys(node) {\n      \"object\" === typeof node &&\n        null !== node &&\n        node.$$typeof === REACT_ELEMENT_TYPE &&\n        node._store &&\n        (node._store.validated = 1);\n    }\n    var React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"),\n      REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n      REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n      REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\n      REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\n      REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n    Symbol.for(\"react.provider\");\n    var REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"),\n      REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\n      REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\n      REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\n      REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"),\n      REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\n      REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\n      REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n      ReactSharedInternals =\n        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n      hasOwnProperty = Object.prototype.hasOwnProperty,\n      isArrayImpl = Array.isArray,\n      createTask = console.createTask\n        ? console.createTask\n        : function () {\n            return null;\n          },\n      specialPropKeyWarningShown;\n    var didWarnAboutElementRef = {};\n    var didWarnAboutKeySpread = {};\n    exports.Fragment = REACT_FRAGMENT_TYPE;\n    exports.jsxDEV = function (\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self\n    ) {\n      return jsxDEVImpl(\n        type,\n        config,\n        maybeKey,\n        isStaticChildren,\n        source,\n        self,\n        Error(\"react-stack-top-frame\"),\n        createTask(getTaskName(type))\n      );\n    };\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7QUFDYixLQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLCtDQUErQyw2QkFBNkI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQkFBZ0IsZ0RBQWdEO0FBQ2hFLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQSxnQ0FBZ0Msa0NBQWtDLE9BQU87QUFDekU7QUFDQSxnR0FBZ0csU0FBUyxVQUFVLHNGQUFzRixhQUFhLFVBQVUsVUFBVTtBQUMxTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLHNHQUEwQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdCQUFnQjtBQUNwQixJQUFJLGNBQWM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyIsInNvdXJjZXMiOlsiL1VzZXJzL2plZmZmb2hsL2Rldi93ZWJzaXRlL2Zyb250ZW5kL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgICAgIGlmIChudWxsID09IHR5cGUpIHJldHVybiBudWxsO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHJldHVybiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFXG4gICAgICAgICAgPyBudWxsXG4gICAgICAgICAgOiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlKSByZXR1cm4gdHlwZTtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiRnJhZ21lbnRcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJQb3J0YWxcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlByb2ZpbGVyXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdHJpY3RNb2RlXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZVwiO1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZUxpc3RcIjtcbiAgICAgIH1cbiAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgc3dpdGNoIChcbiAgICAgICAgICAoXCJudW1iZXJcIiA9PT0gdHlwZW9mIHR5cGUudGFnICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlJlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgdHlwZS4kJHR5cGVvZilcbiAgICAgICAgKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKHR5cGUuZGlzcGxheU5hbWUgfHwgXCJDb250ZXh0XCIpICsgXCIuUHJvdmlkZXJcIjtcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTlNVTUVSX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKHR5cGUuX2NvbnRleHQuZGlzcGxheU5hbWUgfHwgXCJDb250ZXh0XCIpICsgXCIuQ29uc3VtZXJcIjtcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICB2YXIgaW5uZXJUeXBlID0gdHlwZS5yZW5kZXI7XG4gICAgICAgICAgICB0eXBlID0gdHlwZS5kaXNwbGF5TmFtZTtcbiAgICAgICAgICAgIHR5cGUgfHxcbiAgICAgICAgICAgICAgKCh0eXBlID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8IFwiXCIpLFxuICAgICAgICAgICAgICAodHlwZSA9IFwiXCIgIT09IHR5cGUgPyBcIkZvcndhcmRSZWYoXCIgKyB0eXBlICsgXCIpXCIgOiBcIkZvcndhcmRSZWZcIikpO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAoaW5uZXJUeXBlID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsKSxcbiAgICAgICAgICAgICAgbnVsbCAhPT0gaW5uZXJUeXBlXG4gICAgICAgICAgICAgICAgPyBpbm5lclR5cGVcbiAgICAgICAgICAgICAgICA6IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8IFwiTWVtb1wiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgaW5uZXJUeXBlID0gdHlwZS5fcGF5bG9hZDtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLl9pbml0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKGlubmVyVHlwZSkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIFwiXCIgKyB2YWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tLZXlTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICExO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAhMDtcbiAgICAgIH1cbiAgICAgIGlmIChKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQpIHtcbiAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gY29uc29sZTtcbiAgICAgICAgdmFyIEpTQ29tcGlsZXJfdGVtcF9jb25zdCA9IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdC5lcnJvcjtcbiAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMCA9XG4gICAgICAgICAgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIFN5bWJvbCAmJlxuICAgICAgICAgICAgU3ltYm9sLnRvU3RyaW5nVGFnICYmXG4gICAgICAgICAgICB2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddKSB8fFxuICAgICAgICAgIHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgfHxcbiAgICAgICAgICBcIk9iamVjdFwiO1xuICAgICAgICBKU0NvbXBpbGVyX3RlbXBfY29uc3QuY2FsbChcbiAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQsXG4gICAgICAgICAgXCJUaGUgcHJvdmlkZWQga2V5IGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSB1c2luZyBpdCBoZXJlLlwiLFxuICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0VGFza05hbWUodHlwZSkge1xuICAgICAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHJldHVybiBcIjw+XCI7XG4gICAgICBpZiAoXG4gICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiB0eXBlICYmXG4gICAgICAgIG51bGwgIT09IHR5cGUgJiZcbiAgICAgICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFXG4gICAgICApXG4gICAgICAgIHJldHVybiBcIjwuLi4+XCI7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcbiAgICAgICAgcmV0dXJuIG5hbWUgPyBcIjxcIiArIG5hbWUgKyBcIj5cIiA6IFwiPC4uLj5cIjtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgcmV0dXJuIFwiPC4uLj5cIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0T3duZXIoKSB7XG4gICAgICB2YXIgZGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkE7XG4gICAgICByZXR1cm4gbnVsbCA9PT0gZGlzcGF0Y2hlciA/IG51bGwgOiBkaXNwYXRjaGVyLmdldE93bmVyKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBcImtleVwiKSkge1xuICAgICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsIFwia2V5XCIpLmdldDtcbiAgICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2b2lkIDAgIT09IGNvbmZpZy5rZXk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICAgICAgZnVuY3Rpb24gd2FybkFib3V0QWNjZXNzaW5nS2V5KCkge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biB8fFxuICAgICAgICAgICgoc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSAhMCksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSB2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50IHByb3AuIChodHRwczovL3JlYWN0LmRldi9saW5rL3NwZWNpYWwtcHJvcHMpXCIsXG4gICAgICAgICAgICBkaXNwbGF5TmFtZVxuICAgICAgICAgICkpO1xuICAgICAgfVxuICAgICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gITA7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsIFwia2V5XCIsIHtcbiAgICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbGVtZW50UmVmR2V0dGVyV2l0aERlcHJlY2F0aW9uV2FybmluZygpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHRoaXMudHlwZSk7XG4gICAgICBkaWRXYXJuQWJvdXRFbGVtZW50UmVmW2NvbXBvbmVudE5hbWVdIHx8XG4gICAgICAgICgoZGlkV2FybkFib3V0RWxlbWVudFJlZltjb21wb25lbnROYW1lXSA9ICEwKSxcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkFjY2Vzc2luZyBlbGVtZW50LnJlZiB3YXMgcmVtb3ZlZCBpbiBSZWFjdCAxOS4gcmVmIGlzIG5vdyBhIHJlZ3VsYXIgcHJvcC4gSXQgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIEpTWCBFbGVtZW50IHR5cGUgaW4gYSBmdXR1cmUgcmVsZWFzZS5cIlxuICAgICAgICApKTtcbiAgICAgIGNvbXBvbmVudE5hbWUgPSB0aGlzLnByb3BzLnJlZjtcbiAgICAgIHJldHVybiB2b2lkIDAgIT09IGNvbXBvbmVudE5hbWUgPyBjb21wb25lbnROYW1lIDogbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhY3RFbGVtZW50KFxuICAgICAgdHlwZSxcbiAgICAgIGtleSxcbiAgICAgIHNlbGYsXG4gICAgICBzb3VyY2UsXG4gICAgICBvd25lcixcbiAgICAgIHByb3BzLFxuICAgICAgZGVidWdTdGFjayxcbiAgICAgIGRlYnVnVGFza1xuICAgICkge1xuICAgICAgc2VsZiA9IHByb3BzLnJlZjtcbiAgICAgIHR5cGUgPSB7XG4gICAgICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIGtleToga2V5LFxuICAgICAgICBwcm9wczogcHJvcHMsXG4gICAgICAgIF9vd25lcjogb3duZXJcbiAgICAgIH07XG4gICAgICBudWxsICE9PSAodm9pZCAwICE9PSBzZWxmID8gc2VsZiA6IG51bGwpXG4gICAgICAgID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwicmVmXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICAgICAgZ2V0OiBlbGVtZW50UmVmR2V0dGVyV2l0aERlcHJlY2F0aW9uV2FybmluZ1xuICAgICAgICAgIH0pXG4gICAgICAgIDogT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwicmVmXCIsIHsgZW51bWVyYWJsZTogITEsIHZhbHVlOiBudWxsIH0pO1xuICAgICAgdHlwZS5fc3RvcmUgPSB7fTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLl9zdG9yZSwgXCJ2YWxpZGF0ZWRcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICB2YWx1ZTogMFxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJfZGVidWdJbmZvXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwiX2RlYnVnU3RhY2tcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICB2YWx1ZTogZGVidWdTdGFja1xuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJfZGVidWdUYXNrXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6IGRlYnVnVGFza1xuICAgICAgfSk7XG4gICAgICBPYmplY3QuZnJlZXplICYmIChPYmplY3QuZnJlZXplKHR5cGUucHJvcHMpLCBPYmplY3QuZnJlZXplKHR5cGUpKTtcbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBqc3hERVZJbXBsKFxuICAgICAgdHlwZSxcbiAgICAgIGNvbmZpZyxcbiAgICAgIG1heWJlS2V5LFxuICAgICAgaXNTdGF0aWNDaGlsZHJlbixcbiAgICAgIHNvdXJjZSxcbiAgICAgIHNlbGYsXG4gICAgICBkZWJ1Z1N0YWNrLFxuICAgICAgZGVidWdUYXNrXG4gICAgKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBjb25maWcuY2hpbGRyZW47XG4gICAgICBpZiAodm9pZCAwICE9PSBjaGlsZHJlbilcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pXG4gICAgICAgICAgaWYgKGlzQXJyYXlJbXBsKGNoaWxkcmVuKSkge1xuICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgaXNTdGF0aWNDaGlsZHJlbiA9IDA7XG4gICAgICAgICAgICAgIGlzU3RhdGljQ2hpbGRyZW4gPCBjaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICAgIGlzU3RhdGljQ2hpbGRyZW4rK1xuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbltpc1N0YXRpY0NoaWxkcmVuXSk7XG4gICAgICAgICAgICBPYmplY3QuZnJlZXplICYmIE9iamVjdC5mcmVlemUoY2hpbGRyZW4pO1xuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJSZWFjdC5qc3g6IFN0YXRpYyBjaGlsZHJlbiBzaG91bGQgYWx3YXlzIGJlIGFuIGFycmF5LiBZb3UgYXJlIGxpa2VseSBleHBsaWNpdGx5IGNhbGxpbmcgUmVhY3QuanN4cyBvciBSZWFjdC5qc3hERVYuIFVzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgIGVsc2UgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW4pO1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBcImtleVwiKSkge1xuICAgICAgICBjaGlsZHJlbiA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhjb25maWcpLmZpbHRlcihmdW5jdGlvbiAoaykge1xuICAgICAgICAgIHJldHVybiBcImtleVwiICE9PSBrO1xuICAgICAgICB9KTtcbiAgICAgICAgaXNTdGF0aWNDaGlsZHJlbiA9XG4gICAgICAgICAgMCA8IGtleXMubGVuZ3RoXG4gICAgICAgICAgICA/IFwie2tleTogc29tZUtleSwgXCIgKyBrZXlzLmpvaW4oXCI6IC4uLiwgXCIpICsgXCI6IC4uLn1cIlxuICAgICAgICAgICAgOiBcIntrZXk6IHNvbWVLZXl9XCI7XG4gICAgICAgIGRpZFdhcm5BYm91dEtleVNwcmVhZFtjaGlsZHJlbiArIGlzU3RhdGljQ2hpbGRyZW5dIHx8XG4gICAgICAgICAgKChrZXlzID1cbiAgICAgICAgICAgIDAgPCBrZXlzLmxlbmd0aCA/IFwie1wiICsga2V5cy5qb2luKFwiOiAuLi4sIFwiKSArIFwiOiAuLi59XCIgOiBcInt9XCIpLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAnQSBwcm9wcyBvYmplY3QgY29udGFpbmluZyBhIFwia2V5XCIgcHJvcCBpcyBiZWluZyBzcHJlYWQgaW50byBKU1g6XFxuICBsZXQgcHJvcHMgPSAlcztcXG4gIDwlcyB7Li4ucHJvcHN9IC8+XFxuUmVhY3Qga2V5cyBtdXN0IGJlIHBhc3NlZCBkaXJlY3RseSB0byBKU1ggd2l0aG91dCB1c2luZyBzcHJlYWQ6XFxuICBsZXQgcHJvcHMgPSAlcztcXG4gIDwlcyBrZXk9e3NvbWVLZXl9IHsuLi5wcm9wc30gLz4nLFxuICAgICAgICAgICAgaXNTdGF0aWNDaGlsZHJlbixcbiAgICAgICAgICAgIGNoaWxkcmVuLFxuICAgICAgICAgICAga2V5cyxcbiAgICAgICAgICAgIGNoaWxkcmVuXG4gICAgICAgICAgKSxcbiAgICAgICAgICAoZGlkV2FybkFib3V0S2V5U3ByZWFkW2NoaWxkcmVuICsgaXNTdGF0aWNDaGlsZHJlbl0gPSAhMCkpO1xuICAgICAgfVxuICAgICAgY2hpbGRyZW4gPSBudWxsO1xuICAgICAgdm9pZCAwICE9PSBtYXliZUtleSAmJlxuICAgICAgICAoY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihtYXliZUtleSksIChjaGlsZHJlbiA9IFwiXCIgKyBtYXliZUtleSkpO1xuICAgICAgaGFzVmFsaWRLZXkoY29uZmlnKSAmJlxuICAgICAgICAoY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KSwgKGNoaWxkcmVuID0gXCJcIiArIGNvbmZpZy5rZXkpKTtcbiAgICAgIGlmIChcImtleVwiIGluIGNvbmZpZykge1xuICAgICAgICBtYXliZUtleSA9IHt9O1xuICAgICAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBjb25maWcpXG4gICAgICAgICAgXCJrZXlcIiAhPT0gcHJvcE5hbWUgJiYgKG1heWJlS2V5W3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV0pO1xuICAgICAgfSBlbHNlIG1heWJlS2V5ID0gY29uZmlnO1xuICAgICAgY2hpbGRyZW4gJiZcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIoXG4gICAgICAgICAgbWF5YmVLZXksXG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZVxuICAgICAgICAgICAgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBcIlVua25vd25cIlxuICAgICAgICAgICAgOiB0eXBlXG4gICAgICAgICk7XG4gICAgICByZXR1cm4gUmVhY3RFbGVtZW50KFxuICAgICAgICB0eXBlLFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgc2VsZixcbiAgICAgICAgc291cmNlLFxuICAgICAgICBnZXRPd25lcigpLFxuICAgICAgICBtYXliZUtleSxcbiAgICAgICAgZGVidWdTdGFjayxcbiAgICAgICAgZGVidWdUYXNrXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlKSB7XG4gICAgICBcIm9iamVjdFwiID09PSB0eXBlb2Ygbm9kZSAmJlxuICAgICAgICBudWxsICE9PSBub2RlICYmXG4gICAgICAgIG5vZGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSAmJlxuICAgICAgICBub2RlLl9zdG9yZSAmJlxuICAgICAgICAobm9kZS5fc3RvcmUudmFsaWRhdGVkID0gMSk7XG4gICAgfVxuICAgIHZhciBSZWFjdCA9IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3RcIiksXG4gICAgICBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QudHJhbnNpdGlvbmFsLmVsZW1lbnRcIiksXG4gICAgICBSRUFDVF9QT1JUQUxfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wb3J0YWxcIiksXG4gICAgICBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpLFxuICAgICAgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKSxcbiAgICAgIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucHJvZmlsZXJcIik7XG4gICAgU3ltYm9sLmZvcihcInJlYWN0LnByb3ZpZGVyXCIpO1xuICAgIHZhciBSRUFDVF9DT05TVU1FUl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnN1bWVyXCIpLFxuICAgICAgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnRleHRcIiksXG4gICAgICBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmZvcndhcmRfcmVmXCIpLFxuICAgICAgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZVwiKSxcbiAgICAgIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZV9saXN0XCIpLFxuICAgICAgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9cIiksXG4gICAgICBSRUFDVF9MQVpZX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QubGF6eVwiKSxcbiAgICAgIFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UgPSBTeW1ib2wuZm9yKFwicmVhY3QuY2xpZW50LnJlZmVyZW5jZVwiKSxcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzID1cbiAgICAgICAgUmVhY3QuX19DTElFTlRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfV0FSTl9VU0VSU19USEVZX0NBTk5PVF9VUEdSQURFLFxuICAgICAgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LFxuICAgICAgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5LFxuICAgICAgY3JlYXRlVGFzayA9IGNvbnNvbGUuY3JlYXRlVGFza1xuICAgICAgICA/IGNvbnNvbGUuY3JlYXRlVGFza1xuICAgICAgICA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH0sXG4gICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bjtcbiAgICB2YXIgZGlkV2FybkFib3V0RWxlbWVudFJlZiA9IHt9O1xuICAgIHZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbiAgICBleHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbiAgICBleHBvcnRzLmpzeERFViA9IGZ1bmN0aW9uIChcbiAgICAgIHR5cGUsXG4gICAgICBjb25maWcsXG4gICAgICBtYXliZUtleSxcbiAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICBzb3VyY2UsXG4gICAgICBzZWxmXG4gICAgKSB7XG4gICAgICByZXR1cm4ganN4REVWSW1wbChcbiAgICAgICAgdHlwZSxcbiAgICAgICAgY29uZmlnLFxuICAgICAgICBtYXliZUtleSxcbiAgICAgICAgaXNTdGF0aWNDaGlsZHJlbixcbiAgICAgICAgc291cmNlLFxuICAgICAgICBzZWxmLFxuICAgICAgICBFcnJvcihcInJlYWN0LXN0YWNrLXRvcC1mcmFtZVwiKSxcbiAgICAgICAgY3JlYXRlVGFzayhnZXRUYXNrTmFtZSh0eXBlKSlcbiAgICAgICk7XG4gICAgfTtcbiAgfSkoKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw4TEFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qZWZmZm9obC9kZXYvd2Vic2l0ZS9mcm9udGVuZC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["main-app"], () => (__webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fjefffohl%2Fdev%2Fwebsite%2Ffrontend%2Fapp%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);